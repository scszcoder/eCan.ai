name: Release Build eCan
#
# Build platform, CPU architecture and reference can be selected via workflow_dispatch parameters:
#   - platform: windows, macos, all
#   - arch: amd64, aarch64
#   - ref: Branch name or tag (e.g., gui-v2, master, v0.0.4)
#
# Notes:
#   - Windows only supports amd64 architecture (GitHub Actions has no ARM64 runner)
#   - macOS supports amd64/aarch64, but GitHub Actions x86_64 runner needs special handling for arm64 builds
#   - The workflow validates the ref and shows available options if invalid
#
# Examples:
#   - When manually triggering workflow, enter branch/tag name
#   - When pushing tag or publishing release, automatically triggered, default build all + amd64

on:
  # Trigger conditions: create tag or release
  # push:
  #   tags:
  #     - 'v*'  # Match formats like v1.0.0, v2.1.3
  # release:
  #   types: [published, edited, created]
  # Manual trigger
  workflow_dispatch:
    inputs:
      platform:
        description: 'Build platform (windows, macos, all)'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - windows
          - macos
      arch:
        description: 'CPU architecture (all: build all supported, amd64: x86_64 only, aarch64: ARM64 only)'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - amd64
          - aarch64
      ref:
        description: 'Git ref to build (branch name or tag, e.g., master, gui-v2, v0.0.4)'
        required: true
        default: 'master'
        type: string

jobs:
  # Validate ref (tags produce semantic version; branches get fallback version)
  validate-tag:
    runs-on: ubuntu-latest
    outputs:
      tag-valid: ${{ steps.validate.outputs.valid }}
      version: ${{ steps.validate.outputs.version }}
      is-branch: ${{ steps.validate.outputs.is_branch }}
      ref-name: ${{ steps.validate.outputs.ref_name }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.ref || github.ref }}
        fetch-depth: 0  # Fetch all history for tags and branches

    - name: Validate ref and compute version
      id: validate
      shell: bash
      run: |
        set -euo pipefail
        INPUT_REF="${{ github.event.inputs.ref }}"
        REF_FULL="${GITHUB_REF}"

        # Determine the actual ref to use
        if [ -n "$INPUT_REF" ]; then
          REF_NAME="$INPUT_REF"
        else
          REF_NAME="${REF_FULL#refs/*/}"
        fi

        echo "ref_name=$REF_NAME" >> $GITHUB_OUTPUT
        echo "Selected ref: $REF_NAME"

        # Simple validation with helpful error message
        if ! (git show-ref --verify --quiet "refs/heads/$REF_NAME" 2>/dev/null || \
              git show-ref --verify --quiet "refs/tags/$REF_NAME" 2>/dev/null || \
              git show-ref --verify --quiet "refs/remotes/origin/$REF_NAME" 2>/dev/null); then
          echo "[ERROR] Ref '$REF_NAME' does not exist!"
          echo "Available branches: $(git branch -r --format='%(refname:short)' | sed 's/origin\///' | grep -v '^HEAD' | sort | tr '\n' ' ')"
          echo "Available tags: $(git tag --sort=-version:refname | head -5 | tr '\n' ' ')"
          exit 1
        fi

        if [[ "$REF_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9.-]+)?(\+[A-Za-z0-9.-]+)?$ ]]; then
          echo "valid=true" >> $GITHUB_OUTPUT
          echo "is_branch=false" >> $GITHUB_OUTPUT
          echo "version=${REF_NAME#v}" >> $GITHUB_OUTPUT
          echo "Tag detected: $REF_NAME"
        else
          # Treat as branch; read VERSION file as base version
          if [ -f "VERSION" ]; then
            BASE_VERSION=$(cat VERSION | tr -d '[:space:]')
            echo "Read base version from VERSION file: $BASE_VERSION"
          else
            BASE_VERSION="0.0.0"
            echo "VERSION file not found, using default: $BASE_VERSION"
          fi
          
          SHORT_SHA=$(git rev-parse --short HEAD)
          SAFE_BRANCH=$(echo "$REF_NAME" | tr '/' '-')
          FALLBACK="${BASE_VERSION}-${SAFE_BRANCH}-${SHORT_SHA}"
          echo "valid=true" >> $GITHUB_OUTPUT
          echo "is_branch=true" >> $GITHUB_OUTPUT
          echo "version=$FALLBACK" >> $GITHUB_OUTPUT
          echo "Branch detected: $REF_NAME -> version=$FALLBACK"
        fi

  # Windows build
  # Note: Windows only supports amd64 architecture
  build-windows:
    needs: validate-tag
    if: |
      needs.validate-tag.outputs.tag-valid == 'true' &&
      (github.event.inputs.platform == 'windows' ||
       github.event.inputs.platform == 'all' ||
       github.event.inputs.platform == null) &&
      (github.event.inputs.arch == 'amd64' ||
       github.event.inputs.arch == 'all' ||
       github.event.inputs.arch == null)
    runs-on: windows-latest
    env:
      # Expose secrets to env for conditional checks without referencing `secrets` in `if:`
      WIN_CERT_PFX: ${{ secrets.WIN_CERT_PFX || 'NOT_SET' }}
      WIN_CERT_PASSWORD: ${{ secrets.WIN_CERT_PASSWORD || 'NOT_SET' }}
      # Set build architecture for the build process (Windows only supports amd64)
      BUILD_ARCH: amd64
    timeout-minutes: 60

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.ref || github.ref }}
        fetch-depth: 0

    - name: Setup Python Environment
      uses: ./.github/actions/setup-python-env
      with:
        platform: windows
        requirements-file: requirements-windows.txt
        extra-packages: pywin32-ctypes

    - name: Setup Playwright Browsers
      uses: ./.github/actions/setup-playwright
      with:
        platform: windows
        browsers: chromium

    - name: Cache Node.js dependencies
      uses: actions/cache@v4
      with:
        path: gui_v2/node_modules
        # Include architecture in cache key to avoid cross-arch contamination (rollup has native binaries)
        key: ${{ runner.os }}-${{ env.BUILD_ARCH }}-node-${{ hashFiles('gui_v2/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-${{ env.BUILD_ARCH }}-node-

    - name: Setup Node.js Environment
      uses: ./.github/actions/setup-node-env

    - name: Install Windows-specific packages
      run: |
        # Ensure pywin32 is present in the same interpreter
        python -m pip install -U pywin32
        # Rarely needed but safe; registers COM bits
        python -m pywin32_postinstall -install

        echo "=== Verifying pywin32 installation ==="
        python -c "import win32api; print('pywin32 installed successfully')"

    - name: Install Inno Setup
      run: |
        echo "=== Installing Inno Setup ==="
        $DownloadUrl = "https://files.jrsoftware.org/is/6/innosetup-6.2.2.exe"
        $DownloadPath = "$env:TEMP\innosetup-6.2.2.exe"

        Write-Host "Downloading Inno Setup..."
        Invoke-WebRequest -Uri $DownloadUrl -OutFile $DownloadPath -UseBasicParsing

        Write-Host "Installing Inno Setup..."
        Start-Process -FilePath $DownloadPath -ArgumentList "/SILENT", "/SUPPRESSMSGBOXES", "/NORESTART" -Wait

        Write-Host "Inno Setup installation completed"

        # Verify installation
        $innoPath = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
        if (Test-Path $innoPath) {
            Write-Host "Inno Setup verified at: $innoPath"
        } else {
            Write-Host "ERROR: Inno Setup not found at expected location"
            exit 1
        }

    - name: Verify Inno Setup (Unicode) version
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Continue'
        $innoPath = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
        if (-not (Test-Path $innoPath)) { $innoPath = "${env:ProgramFiles}\Inno Setup 6\ISCC.exe" }
        if (-not (Test-Path $innoPath)) {
          Write-Host "ERROR: ISCC.exe not found" -ForegroundColor Red
          exit 1
        }
        Write-Host "=== ISCC Version Output ===" -ForegroundColor Cyan
        $help = & $innoPath '/?'
        # Note: ISCC /? may return non-zero exit code even on success, so we don't check $LASTEXITCODE
        $help | ForEach-Object { "  $_" }
        # Join lines for reliable regex matching; avoids array -notmatch pitfalls
        $helpText = $help -join "`n"
        if (-not ($helpText -match 'Inno Setup\s+\d')) {
          Write-Host "ERROR: Failed to get ISCC version" -ForegroundColor Red
          exit 1
        }
        # Inno Setup 6 compiler is Unicode-only; log as info if not explicitly present
        $unicodeHint = ($helpText -match 'Unicode') -or ((Get-Item $innoPath).VersionInfo.FileDescription -match 'Unicode')
        if (-not $unicodeHint) {
          Write-Host "INFO: Proceeding - Inno Setup 6 is Unicode-only; explicit 'Unicode' string not found in help." -ForegroundColor Yellow
        } else {
          Write-Host "OK: ISCC Unicode build detected" -ForegroundColor Green
        }
        Write-Host "OK: ISCC check passed" -ForegroundColor Green
        exit 0

    - name: Install Inno Setup Chinese Language Pack
      run: |
        echo "=== Installing Inno Setup Chinese Language Pack ==="
        # Detect actual Inno Setup installation path
        $innoPath = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
        if (-not (Test-Path $innoPath)) { $innoPath = "${env:ProgramFiles}\Inno Setup 6\ISCC.exe" }
        if (-not (Test-Path $innoPath)) {
            Write-Host "ERROR: ISCC.exe not found; cannot determine Languages directory" -ForegroundColor Red
            exit 1
        }

        # Languages directory is two levels up from ISCC.exe, then \Languages
        $installDir = Split-Path -Parent $innoPath         # e.g. ...\Inno Setup 6
        $langDir = Join-Path $installDir 'Languages'
        $langPath = Join-Path $langDir 'ChineseSimplified.isl'
        $SourcePath = "${{ github.workspace }}\build_system\inno_setup_languages\ChineseSimplified.isl"

        Write-Host "Installing from repository: $SourcePath"
        Write-Host "Target Languages directory: $langDir"

        # Verify source file exists
        if (-not (Test-Path $SourcePath)) {
            Write-Host "ERROR: Source language file not found: $SourcePath" -ForegroundColor Red
            exit 1
        }

        # Ensure Languages directory exists
        if (-not (Test-Path $langDir)) { New-Item -ItemType Directory -Path $langDir -Force | Out-Null }

        # Copy with encoding preservation
        Copy-Item -Path $SourcePath -Destination $langPath -Force
        Write-Host "✓ Chinese language pack installed from repository" -ForegroundColor Green

        # Verify installation
        if (Test-Path $langPath) {
            $fileSize = (Get-Item $langPath).Length
            Write-Host "✓ File verified at: $langPath" -ForegroundColor Green
            Write-Host "  File size: $fileSize bytes" -ForegroundColor Gray
            
            # Verify content
            $content = Get-Content $langPath -Raw -Encoding UTF8 -ErrorAction SilentlyContinue
            # Use single-quoted strings to avoid PowerShell variable interpolation; check both markers
            if (($content -match 'LanguageID=\$0804') -and ($content -match 'LanguageCodePage=936')) {
                Write-Host "✓ Language file markers verified (LanguageID=$0804, CodePage=936)" -ForegroundColor Green
            } else {
                Write-Host "⚠ WARNING: Could not verify required markers (LanguageID=$0804 & LanguageCodePage=936)" -ForegroundColor Yellow
            }
        } else {
            Write-Host "ERROR: Chinese language pack not found at expected location" -ForegroundColor Red
            exit 1
        }

    - name: Setup OTA Dependencies
      uses: ./.github/actions/setup-ota-deps
      with:
        platform: windows

    - name: Setup Build Directories
      uses: ./.github/actions/setup-build-dirs
      with:
        platform: windows

    - name: Check Build Environment
      uses: ./.github/actions/check-build-env
      with:
        platform: windows

    - name: Setup Windows signtool Environment
      uses: ./.github/actions/setup-signtool-env
      with:
        skip-if-available: true
        sdk-version: '2004'
        timeout: '600'

    - name: Check Windows Architecture Selection
      run: |
        echo "=== Checking Windows Architecture Selection ==="
        echo "Selected architecture: ${{ github.event.inputs.arch || 'all (default)' }}"
        echo "Platform: ${{ github.event.inputs.platform || 'all (default)' }}"
        echo "Note: Windows only supports amd64 architecture"

        # Architecture selection logic for Windows
        $INPUT_ARCH = "${{ github.event.inputs.arch }}"
        if ($INPUT_ARCH -eq "aarch64") {
          Write-Host "ERROR: Windows does not support aarch64 architecture" -ForegroundColor Red
          Write-Host "INFO: Windows only supports amd64 (x86_64) architecture" -ForegroundColor Yellow
          Write-Host "INFO: Please select 'amd64' or 'all' for Windows builds" -ForegroundColor Yellow
          exit 1
        } elseif ($INPUT_ARCH -eq "all" -or $INPUT_ARCH -eq "amd64" -or [string]::IsNullOrEmpty($INPUT_ARCH)) {
          Write-Host "INFO: Building Windows amd64 version" -ForegroundColor Green
        } else {
          Write-Host "ERROR: Unsupported architecture '$INPUT_ARCH' for Windows" -ForegroundColor Red
          Write-Host "INFO: Windows only supports amd64 architecture" -ForegroundColor Yellow
          exit 1
        }

    - name: Clean build artifacts
      shell: pwsh
      run: |
        Write-Host "=== Cleaning build artifacts ===" -ForegroundColor Cyan
        Remove-Item -Path dist, build -Recurse -Force -ErrorAction SilentlyContinue
        Remove-Item -Path *.spec -Force -ErrorAction SilentlyContinue
        Write-Host "Cleaned dist/, build/, and spec files" -ForegroundColor Green

    - name: Build Windows EXE
      shell: pwsh
      run: |
        Write-Host "=== Starting Windows Build ===" -ForegroundColor Cyan
        Write-Host "Command: python build.py prod" -ForegroundColor Gray

        # Set environment variables
        $env:PYTHONPATH = "$PWD"
        $env:PYTHONUNBUFFERED = "1"
        $env:VIRTUAL_ENV = "$PWD\.venv"
        $env:PATH = "$PWD\.venv\Scripts;$env:PATH"

        # Verify build architecture environment variable
        Write-Host "BUILD_ARCH environment variable: $env:BUILD_ARCH"

        # Verify virtual environment and dependencies
        Write-Host "=== Verifying Build Environment ==="
        Write-Host "Python executable: $((Get-Command python).Source)"
        Write-Host "Virtual environment: $env:VIRTUAL_ENV"

        # Test key dependencies
        python -c "
        import sys
        print(f'Python version: {sys.version}')
        print(f'Python executable: {sys.executable}')
        packages = ['PyInstaller', 'PySide6', 'requests', 'playwright', 'colorlog']
        for pkg in packages:
            try:
                __import__(pkg)
                print(f'[OK] {pkg} available')
            except ImportError as e:
                print(f'[ERROR] {pkg} not found: {e}')
        "

        # Run build with detailed output (Sparkle support is automatic on macOS)
        python build.py prod --version ${{ needs.validate-tag.outputs.version }} 2>&1 | Tee-Object -FilePath "build.log"

        # Check if build succeeded by verifying key files exist
        $buildSuccess = $true
        $srcExe = "dist/eCan/eCan.exe"
        if (!(Test-Path $srcExe)) {
            Write-Host "[ERROR] Build failed - main executable not found: $srcExe" -ForegroundColor Red
            $buildSuccess = $false
        }

        # Check for standardized artifacts (created by build.py)
        $stdExe = "dist/eCan-${{ needs.validate-tag.outputs.version }}-windows-$env:BUILD_ARCH.exe"

        if ($buildSuccess) {
            if (Test-Path $stdExe) {
                Write-Host "[OK] Standardized executable found: $stdExe"
            } else {
                Write-Host "[WARN] Standardized executable not found, creating manually..."
                if (Test-Path $srcExe) {
                    Copy-Item -LiteralPath $srcExe -Destination $stdExe -Force
                    Write-Host "Created: $stdExe"
                }
            }
        }

        if (-not $buildSuccess) {
            Write-Host "=== Build Log ===" -ForegroundColor Yellow
            Get-Content "build.log"
            exit 1
        }

        Write-Host "[OK] Build completed successfully" -ForegroundColor Green

        Write-Host "=== Validating Build Artifacts ===" -ForegroundColor Cyan
        python build_system/build_validator.py --artifacts --version ${{ needs.validate-tag.outputs.version }} --arch $env:BUILD_ARCH
        if ($LASTEXITCODE -ne 0) {
            Write-Host "[ERROR] Build artifact validation failed" -ForegroundColor Red
            exit 1
        }

        Write-Host "=== Verifying OTA artifacts in dist ===" -ForegroundColor Cyan
        # Only check app bundle directory (dist/eCan/third_party/)
        # This is what gets packaged into the installer
        $winSparklePath = "dist/eCan/third_party/winsparkle/winsparkle.dll"
        if (Test-Path $winSparklePath) {
          Write-Host "[OK] winSparkle DLL packaged at: $winSparklePath"
          $dll = Get-Item $winSparklePath
          Write-Host "   Size: $([math]::Round($dll.Length / 1KB, 2)) KB"
        } else {
          Write-Host "[WARN] winSparkle DLL not found at: $winSparklePath"
          Write-Host "[WARN] OTA (Windows) may be disabled"
        }


    - name: Code sign Windows artifacts (optional)
      if: ${{ env.WIN_CERT_PFX != 'NOT_SET' && env.WIN_CERT_PASSWORD != 'NOT_SET' }}
      env:
        WIN_CERT_PFX: ${{ env.WIN_CERT_PFX }}
        WIN_CERT_PASSWORD: ${{ env.WIN_CERT_PASSWORD }}
      run: |
        echo "=== Code signing Windows artifacts ==="
        echo "Certificate status: Available"
        echo "Password status: Available"
        $pfxPath = "$env:RUNNER_TEMP\codesign.pfx"
        [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:WIN_CERT_PFX))
        $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\x64\signtool.exe"
        if (-not (Test-Path $signtool)) { $signtool = "signtool.exe" }

        $files = @()
        # Sign distribution executables in top-level dist (avoid signing internal app binaries)
        $exeFiles = Get-ChildItem -Path "dist" -Filter "*.exe" -File -ErrorAction SilentlyContinue
        foreach ($ef in $exeFiles) { $files += $ef.FullName }
        # Optionally sign MSI installers if present
        $msiFiles = Get-ChildItem -Path "dist" -Filter "*.msi" -File -ErrorAction SilentlyContinue
        foreach ($mf in $msiFiles) { $files += $mf.FullName }

        foreach ($f in $files) {
          Write-Host "Signing $f"
          & $signtool sign /fd SHA256 /f $pfxPath /p $env:WIN_CERT_PASSWORD /tr http://timestamp.digicert.com /td SHA256 $f
          if ($LASTEXITCODE -ne 0) { Write-Host "Sign failed: $f"; exit 1 }
        }
        Write-Host "Windows code signing done"

    - name: Check build result
      shell: pwsh
      run: |
        Write-Host "=== Build Result Check ===" -ForegroundColor Cyan
        Write-Host "=== Environment Variables Summary ===" -ForegroundColor Cyan
        Write-Host "Windows Code Signing:" -ForegroundColor Yellow
        Write-Host "  WIN_CERT_PFX: ${{ env.WIN_CERT_PFX != 'NOT_SET' && 'Available' || 'Not Available' }}" -ForegroundColor Gray
        Write-Host "  WIN_CERT_PASSWORD: ${{ env.WIN_CERT_PASSWORD != 'NOT_SET' && 'Available' || 'Not Available' }}" -ForegroundColor Gray
        Write-Host "  Status: ${{ env.WIN_CERT_PFX != 'NOT_SET' && env.WIN_CERT_PASSWORD != 'NOT_SET' && 'Ready for signing' || 'Skipping signing' }}" -ForegroundColor Gray
        
        Write-Host "Dist directory contents:" -ForegroundColor Yellow
        Get-ChildItem -Path "dist" -Recurse | Format-Table -AutoSize

        $exeFound = $false
        $setupFound = $false

        if (Test-Path "dist/eCan/eCan.exe") {
            $exe = Get-Item "dist/eCan/eCan.exe"
            Write-Host "Windows EXE found: dist/eCan/eCan.exe" -ForegroundColor Green
            Write-Host "   Size: $([math]::Round($exe.Length / 1MB, 2)) MB" -ForegroundColor Gray
            Write-Host "   Created: $($exe.CreationTime)" -ForegroundColor Gray
            $exeFound = $true
        } else {
            Write-Host "ERROR: Windows EXE not found" -ForegroundColor Red
            Write-Host "Searching for .exe files..." -ForegroundColor Yellow
            Get-ChildItem -Path "dist" -Recurse -Filter "*.exe" | ForEach-Object {
                Write-Host "   Found: $($_.FullName)" -ForegroundColor Gray
            }
        }

        # Check for standardized installer
        $stdSetup = "dist/eCan-${{ needs.validate-tag.outputs.version }}-windows-$env:BUILD_ARCH-Setup.exe"

        if (Test-Path $stdSetup) {
            $setup = Get-Item $stdSetup
            Write-Host "Installer found: $stdSetup" -ForegroundColor Green
            Write-Host "   Size: $([math]::Round($setup.Length / 1MB, 2)) MB" -ForegroundColor Gray
            Write-Host "   Created: $($setup.CreationTime)" -ForegroundColor Gray
            $setupFound = $true
        } else {
            Write-Host "WARN: No installer found: $stdSetup" -ForegroundColor Yellow
        }

        if (-not $exeFound) {
            Write-Host "ERROR: Build validation failed - no executable found" -ForegroundColor Red
            exit 1
        }

        Write-Host "Build validation passed" -ForegroundColor Green

    - name: Compress Windows artifacts for upload
      shell: pwsh
      run: |
        Write-Host "=== Compressing Windows artifacts ===" -ForegroundColor Cyan
        $version = "${{ needs.validate-tag.outputs.version }}"
        $arch = "$env:BUILD_ARCH"
        
        # Create artifacts directory
        New-Item -ItemType Directory -Force -Path "artifacts" | Out-Null
        
        # Copy main installer
        $setupFile = "dist/eCan-${version}-windows-${arch}-Setup.exe"
        if (Test-Path $setupFile) {
          Copy-Item $setupFile "artifacts/" -Force
          $size = [math]::Round((Get-Item $setupFile).Length / 1MB, 2)
          Write-Host "Copied installer: ${size} MB"
        }
        
        # Copy MSI files if exist
        Get-ChildItem "dist/*.msi" -ErrorAction SilentlyContinue | ForEach-Object {
          Copy-Item $_.FullName "artifacts/" -Force
          Write-Host "Copied MSI: $($_.Name)"
        }
        
        Write-Host "Artifacts prepared for upload"
        Get-ChildItem "artifacts" | ForEach-Object {
          $sizeMB = [math]::Round($_.Length / 1MB, 2)
          Write-Host "  $($_.Name): ${sizeMB} MB"
        }

    - name: Upload Windows artifacts
      uses: actions/upload-artifact@v4
      with:
        name: eCan-Windows-${{ needs.validate-tag.outputs.version }}
        path: artifacts/
        retention-days: 30
        compression-level: 6

  # macOS build - Matrix strategy for multiple architectures
  build-macos:
    needs: validate-tag
    if: |
      needs.validate-tag.outputs.tag-valid == 'true' &&
      (github.event.inputs.platform == 'macos' ||
       github.event.inputs.platform == 'all' ||
       github.event.inputs.platform == null)
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - arch: amd64
            target_arch: x86_64
            build_name: "amd64"
            pyinstaller_arch: "x86_64"
            runner: "macos-15-intel"  # Intel x86_64 runner (macOS 15 Intel)
          - arch: aarch64
            target_arch: arm64
            build_name: "aarch64"
            pyinstaller_arch: "arm64"
            runner: "macos-latest"  # Apple Silicon ARM64 runner (macOS 15 arm64)
      fail-fast: false
    env:
      # Expose macOS signing/notarization secrets to env for conditional checks without referencing `secrets` in `if:`
      MAC_CERT_P12: ${{ secrets.MAC_CERT_P12 || 'NOT_SET' }}
      MAC_CERT_PASSWORD: ${{ secrets.MAC_CERT_PASSWORD || 'NOT_SET' }}
      MAC_CODESIGN_IDENTITY: ${{ secrets.MAC_CODESIGN_IDENTITY || 'NOT_SET' }}
      APPLE_ID: ${{ secrets.APPLE_ID || 'NOT_SET' }}
      APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD || 'NOT_SET' }}
      TEAM_ID: ${{ secrets.TEAM_ID || 'NOT_SET' }}
      # Set build architecture for the build process
      BUILD_ARCH: ${{ matrix.arch }}
      TARGET_ARCH: ${{ matrix.target_arch }}
      PYINSTALLER_TARGET_ARCH: ${{ matrix.pyinstaller_arch }}
    timeout-minutes: 60

    steps:
    - name: Check if this architecture should be built
      id: should_build
      run: |
        ARCH="${{ matrix.arch }}"
        INPUT_ARCH="${{ github.event.inputs.arch }}"
        INPUT_PLATFORM="${{ github.event.inputs.platform }}"

        echo "Matrix arch: $ARCH"
        echo "Input arch: $INPUT_ARCH"
        echo "Input platform: $INPUT_PLATFORM"

        # Determine if this matrix job should run
        SHOULD_BUILD="false"

        # Logic for architecture selection
        if [ "$INPUT_ARCH" = "all" ]; then
          # Build all architectures when arch is 'all'
          SHOULD_BUILD="true"
          echo "Building $ARCH because arch=all"
        elif [ "$INPUT_ARCH" = "$ARCH" ]; then
          # Build only the specified architecture
          SHOULD_BUILD="true"
          echo "Building $ARCH because it matches input arch"
        elif [ -z "$INPUT_ARCH" ] || [ "$INPUT_ARCH" = "null" ]; then
          # Default to all architectures when no arch specified
          SHOULD_BUILD="true"
          echo "Building $ARCH because no arch specified (default to all)"
        else
          echo "Skipping $ARCH because it doesn't match input arch ($INPUT_ARCH)"
        fi

        echo "should_build=$SHOULD_BUILD" >> $GITHUB_OUTPUT
        echo "Final decision: Should build $ARCH = $SHOULD_BUILD"

    - name: Checkout code
      if: steps.should_build.outputs.should_build == 'true'
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.ref || github.ref }}
        fetch-depth: 0

    - name: Setup Python Environment
      if: steps.should_build.outputs.should_build == 'true'
      uses: ./.github/actions/setup-python-env
      with:
        platform: macos
        requirements-file: requirements-macos.txt
        python-version: ${{ matrix.arch == 'aarch64' && '3.11' || '3.11' }}

    - name: Setup Playwright Browsers
      if: steps.should_build.outputs.should_build == 'true'
      uses: ./.github/actions/setup-playwright
      with:
        platform: macos
        arch: ${{ matrix.arch }}
        browsers: chromium

    - name: Cache Node.js dependencies
      if: steps.should_build.outputs.should_build == 'true'
      uses: actions/cache@v4
      with:
        path: gui_v2/node_modules
        # Include architecture in cache key to avoid cross-arch contamination (rollup has native binaries)
        key: ${{ runner.os }}-${{ matrix.arch }}-node-${{ hashFiles('gui_v2/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-${{ matrix.arch }}-node-

    - name: Setup Node.js Environment
      if: steps.should_build.outputs.should_build == 'true'
      uses: ./.github/actions/setup-node-env

    - name: Check macOS package architectures
      if: steps.should_build.outputs.should_build == 'true'
      run: |
        echo "=== Checking installed package architectures ==="
        python -c "
        import platform
        import sys
        print(f'Python executable: {sys.executable}')
        print(f'Python platform: {platform.platform()}')
        print(f'Python machine: {platform.machine()}')
        try:
            import numpy
            print(f'NumPy version: {numpy.__version__}')
        except ImportError:
            print('NumPy not installed')
        try:
            import PySide6
            print(f'PySide6 available')
        except ImportError:
            print('PySide6 not available')
        "

    - name: Setup OTA Dependencies
      if: steps.should_build.outputs.should_build == 'true'
      uses: ./.github/actions/setup-ota-deps
      with:
        platform: macos

    - name: Setup Build Directories
      if: steps.should_build.outputs.should_build == 'true'
      uses: ./.github/actions/setup-build-dirs
      with:
        platform: macos

    - name: Setup Xcode License
      if: steps.should_build.outputs.should_build == 'true'
      uses: ./.github/actions/setup-xcode-license
      with:
        platform: macos

    - name: Check Build Environment
      if: steps.should_build.outputs.should_build == 'true'
      uses: ./.github/actions/check-build-env
      with:
        platform: macos
        matrix-arch: ${{ matrix.arch }}
        matrix-target-arch: ${{ matrix.target_arch }}
        matrix-pyinstaller-arch: ${{ matrix.pyinstaller_arch }}

    - name: Clean build artifacts
      if: steps.should_build.outputs.should_build == 'true'
      run: |
        echo "=== Cleaning build artifacts ==="
        rm -rf dist/ build/ *.spec
        echo "Cleaned dist/, build/, and spec files"

    - name: Build macOS App
      if: steps.should_build.outputs.should_build == 'true'
      run: |
        echo "=== Starting macOS Build ==="
        echo "Command: python build.py prod"

        # Set environment variables
        export PYTHONPATH="$PWD"
        export PYTHONUNBUFFERED=1
        # Use matrix architecture instead of input arch
        export BUILD_ARCH="${{ matrix.arch }}"
        export TARGET_ARCH="${{ matrix.target_arch }}"

        echo "Building for architecture: $BUILD_ARCH (target: $TARGET_ARCH)"

        # Configure architecture-specific build settings
        if [ "${{ matrix.arch }}" = "aarch64" ]; then
          echo "[INFO] Configuring ARM64 (Apple Silicon) build on native ARM64 runner"
          export ARCHFLAGS="-arch arm64"
          export _PYTHON_HOST_PLATFORM="macosx-11.0-arm64"
          export MACOSX_DEPLOYMENT_TARGET="11.0"
          export CMAKE_OSX_ARCHITECTURES="arm64"
          export CMAKE_APPLE_SILICON_PROCESSOR="arm64"
          # Use ARM64 wheels on native ARM64 runner
          export PIP_PLATFORM="macosx_11_0_arm64"
          export PYINSTALLER_TARGET_ARCH="arm64"
          export TARGET_ARCH="arm64"
          echo "[INFO] ARM64 native environment configured"
        else
          echo "[INFO] Configuring Intel (x86_64) build on native Intel runner"
          export ARCHFLAGS="-arch x86_64"
          export _PYTHON_HOST_PLATFORM="macosx-10.15-x86_64"
          export MACOSX_DEPLOYMENT_TARGET="10.15"
          export CMAKE_OSX_ARCHITECTURES="x86_64"
          # Use x86_64 wheels on native Intel runner
          export PIP_PLATFORM="macosx_10_15_x86_64"
          export PYINSTALLER_TARGET_ARCH="x86_64"
          export TARGET_ARCH="x86_64"
          echo "[INFO] Intel native environment configured"
        fi

        # Verify Python architecture
        echo "[INFO] Python architecture check:"
        python -c "import platform; print(f'Python platform: {platform.platform()}'); print(f'Python machine: {platform.machine()}'); print(f'Python architecture: {platform.architecture()}')"

        # Run build with detailed output (Sparkle support is automatic on macOS)
        python build.py prod --version ${{ needs.validate-tag.outputs.version }} 2>&1 | tee build.log

        # Check if build succeeded by verifying key files exist
        BUILD_SUCCESS=true
        APP_PATH="dist/eCan.app"
        if [ ! -d "$APP_PATH" ]; then
            echo "[ERROR] Build failed - app bundle not found: $APP_PATH"
            BUILD_SUCCESS=false
        fi

        # Check for standardized PKG (created by build.py)
        ARCH="$BUILD_ARCH"
        VERSION="${{ needs.validate-tag.outputs.version }}"
        STD_PKG="dist/eCan-${VERSION}-macos-${ARCH}.pkg"

        if [ "$BUILD_SUCCESS" = "true" ]; then
            if [ -f "$STD_PKG" ]; then
                echo "[OK] Standardized PKG found: $STD_PKG"
            else
                echo "[ERROR] Standardized PKG not found: $STD_PKG"
                echo "[ERROR] PKG installer creation failed during build"
                echo "[INFO] Contents of dist/ directory:"
                ls -la dist/ || true
                BUILD_SUCCESS=false
            fi
        fi

        if [ "$BUILD_SUCCESS" != "true" ]; then
            echo "=== Build Log ==="
            cat build.log
            exit 1
        fi

        echo "[OK] Build completed successfully"

    - name: Validate build artifacts
      if: steps.should_build.outputs.should_build == 'true'
      run: |
        echo "=== Validating Build Artifacts ==="
        python build_system/build_validator.py --artifacts --version ${{ needs.validate-tag.outputs.version }} --arch $BUILD_ARCH
        if [ $? -ne 0 ]; then
            echo "[ERROR] Build artifact validation failed"
            exit 1
        fi

    - name: Verify architecture
      if: steps.should_build.outputs.should_build == 'true'
      env:
        BUILD_ARCH: ${{ env.BUILD_ARCH }}
        TARGET_ARCH: ${{ env.TARGET_ARCH }}
        PYINSTALLER_TARGET_ARCH: ${{ env.PYINSTALLER_TARGET_ARCH }}
        VERSION: ${{ needs.validate-tag.outputs.version }}
      run: |
        echo "=== Verifying Build Architecture ==="
        python build_system/verify_architecture.py
        if [ $? -ne 0 ]; then
            echo "[ERROR] Architecture verification failed"
            exit 1
        fi







    - name: Code sign macOS app (optional)
      if: ${{ steps.should_build.outputs.should_build == 'true' && env.MAC_CERT_P12 != 'NOT_SET' && env.MAC_CERT_PASSWORD != 'NOT_SET' && env.MAC_CODESIGN_IDENTITY != 'NOT_SET' }}
      env:
        MAC_CERT_P12: ${{ env.MAC_CERT_P12 }}
        MAC_CERT_PASSWORD: ${{ env.MAC_CERT_PASSWORD }}
        MAC_CODESIGN_IDENTITY: ${{ env.MAC_CODESIGN_IDENTITY }}
      run: |
        echo "=== Code signing macOS app (if secrets provided) ==="
        echo "Certificate status: Available"
        echo "Password status: Available"
        echo "Identity status: Available"
        if [ -z "${MAC_CERT_P12}" ] || [ -z "${MAC_CERT_PASSWORD}" ] || [ -z "${MAC_CODESIGN_IDENTITY}" ]; then
          echo "No macOS signing secrets; skip codesign"
          exit 0
        fi
        CERT_PATH="$RUNNER_TEMP/cert.p12"
        echo "$MAC_CERT_P12" | base64 --decode > "$CERT_PATH"
        KEYCHAIN=build.keychain
        KEYCHAIN_PW="actions"
        security create-keychain -p "$KEYCHAIN_PW" "$KEYCHAIN"
        security set-keychain-settings -lut 21600 "$KEYCHAIN"
        security unlock-keychain -p "$KEYCHAIN_PW" "$KEYCHAIN"
        security import "$CERT_PATH" -k "$KEYCHAIN" -P "$MAC_CERT_PASSWORD" -T /usr/bin/codesign
        security list-keychain -d user -s "$KEYCHAIN" login.keychain
        if [ -d "dist/eCan.app" ]; then
          echo "Signing dist/eCan.app"
          codesign --deep --force --options runtime --sign "$MAC_CODESIGN_IDENTITY" "dist/eCan.app"
          codesign --verify --deep --strict --verbose=2 "dist/eCan.app"
        else
          echo "dist/eCan.app not found; skip codesign"
        fi

    - name: Notarize macOS PKG (optional)
      if: ${{ steps.should_build.outputs.should_build == 'true' && env.APPLE_ID != 'NOT_SET' && env.APPLE_APP_SPECIFIC_PASSWORD != 'NOT_SET' && env.TEAM_ID != 'NOT_SET' }}
      env:
        APPLE_ID: ${{ env.APPLE_ID }}
        APPLE_APP_SPECIFIC_PASSWORD: ${{ env.APPLE_APP_SPECIFIC_PASSWORD }}
        TEAM_ID: ${{ env.TEAM_ID }}
      run: |
        echo "=== Notarize macOS PKG (if Apple credentials provided) ==="
        if [ -z "${APPLE_ID}" ] || [ -z "${APPLE_APP_SPECIFIC_PASSWORD}" ] || [ -z "${TEAM_ID}" ]; then
          echo "No Apple notarization credentials; skip notarization"
          exit 0
        fi
        ARCH="$BUILD_ARCH"
        VERSION="${{ needs.validate-tag.outputs.version }}"
        PKG_PATH="dist/eCan-${VERSION}-macos-${ARCH}.pkg"
        if [ -f "$PKG_PATH" ]; then
          echo "Submitting $PKG_PATH for notarization..."
          xcrun notarytool submit "$PKG_PATH" --apple-id "$APPLE_ID" --password "$APPLE_APP_SPECIFIC_PASSWORD" --team-id "$TEAM_ID" --wait
          if [ $? -eq 0 ]; then
            echo "Stapling notarization to PKG..."
            xcrun stapler staple "$PKG_PATH"
            echo "[OK] Notarization and stapling completed"
          else
            echo "[WARN] Notarization failed"
          fi
        else
          echo "PKG not found, skip notarization"
        fi

    - name: Check build result
      if: steps.should_build.outputs.should_build == 'true'
      run: |
        echo "=== Build Result Check ==="
        echo "=== Environment Variables Summary ==="
        echo "macOS Code Signing:"
        echo "  MAC_CERT_P12: ${{ env.MAC_CERT_P12 != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  MAC_CERT_PASSWORD: ${{ env.MAC_CERT_PASSWORD != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  MAC_CODESIGN_IDENTITY: ${{ env.MAC_CODESIGN_IDENTITY != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  Status: ${{ env.MAC_CERT_P12 != 'NOT_SET' && env.MAC_CERT_PASSWORD != 'NOT_SET' && env.MAC_CODESIGN_IDENTITY != 'NOT_SET' && 'Ready for signing' || 'Skipping signing' }}"
        
        echo "macOS Notarization:"
        echo "  APPLE_ID: ${{ env.APPLE_ID != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  APPLE_APP_SPECIFIC_PASSWORD: ${{ env.APPLE_APP_SPECIFIC_PASSWORD != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  TEAM_ID: ${{ env.TEAM_ID != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  Status: ${{ env.APPLE_ID != 'NOT_SET' && env.APPLE_APP_SPECIFIC_PASSWORD != 'NOT_SET' && env.TEAM_ID != 'NOT_SET' && 'Ready for notarization' || 'Skipping notarization' }}"
        
        echo "Dist directory contents:"
        ls -la dist/

        ARCH="$BUILD_ARCH"
        VERSION="${{ needs.validate-tag.outputs.version }}"
        PKG_PATH="dist/eCan-${VERSION}-macos-${ARCH}.pkg"
        if [ -f "$PKG_PATH" ]; then
            echo "[OK] macOS PKG found: $PKG_PATH"
            pkg_size=$(du -sh "$PKG_PATH" | cut -f1)
            echo "   Size: $pkg_size"

            # Verify PKG architecture
            echo "=== Verifying PKG Architecture ==="
            if command -v pkgutil >/dev/null 2>&1; then
                echo "PKG contents:"
                pkgutil --payload-files "$PKG_PATH" | head -10
            fi
        elif [ -d "dist/eCan.app" ]; then
            echo "[OK] macOS App found: dist/eCan.app"
            app_size=$(du -sh dist/eCan.app | cut -f1)
            echo "   Size: $app_size"
            echo "   App structure:"
            find dist/eCan.app -type f -name "eCan" | head -5

            # Verify app bundle architecture
            echo "=== Verifying App Bundle Architecture ==="
            if [ -f "dist/eCan.app/Contents/MacOS/eCan" ]; then
                echo "Main executable architecture:"
                file "dist/eCan.app/Contents/MacOS/eCan" || echo "Could not determine architecture"
                if command -v lipo >/dev/null 2>&1; then
                    echo "Detailed architecture info:"
                    lipo -info "dist/eCan.app/Contents/MacOS/eCan" || echo "lipo failed"
                fi
            fi
        else
            echo "[ERROR] macOS build not found"
            echo "Searching for .pkg and .app files..."
            find dist -name "*.pkg" 2>/dev/null || echo "No .pkg files found"
            find dist -name "*.app" 2>/dev/null || echo "No .app files found"
            exit 1
        fi

        echo "[OK] Build validation passed"

    - name: Compress macOS artifacts for upload
      if: steps.should_build.outputs.should_build == 'true'
      id: compress_artifacts
      run: |
        echo "=== Compressing macOS artifacts ==="
        VERSION="${{ needs.validate-tag.outputs.version }}"
        ARCH="${{ matrix.arch }}"
        
        # Create artifacts directory
        mkdir -p artifacts
        
        # Copy main PKG file
        PKG_FILE="dist/eCan-${VERSION}-macos-${ARCH}.pkg"
        if [ -f "$PKG_FILE" ]; then
          cp "$PKG_FILE" artifacts/
          SIZE=$(du -sh "$PKG_FILE" | cut -f1)
          echo "Copied PKG: ${SIZE}"
          echo "has_artifacts=true" >> $GITHUB_OUTPUT
        else
          echo "[ERROR] PKG file not found: $PKG_FILE"
          echo "[ERROR] Build may have failed or PKG was not created"
          echo "Contents of dist/ directory:"
          ls -la dist/ || true
          echo "has_artifacts=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "Artifacts prepared for upload:"
        ls -lh artifacts/

    - name: Upload macOS artifacts
      if: steps.should_build.outputs.should_build == 'true' && steps.compress_artifacts.outputs.has_artifacts == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: eCan-macOS-${{ matrix.arch }}-${{ needs.validate-tag.outputs.version }}
        path: artifacts/
        retention-days: 30
        compression-level: 6
        if-no-files-found: error






  # Upload to AWS S3
  upload-to-s3:
    needs: [validate-tag, build-windows, build-macos]
    if: |
      always() &&
      needs.validate-tag.outputs.tag-valid == 'true' &&
      (
        (github.event.inputs.platform == 'windows' && needs.build-windows.result == 'success') ||
        (github.event.inputs.platform == 'macos' && needs.build-macos.result == 'success') ||
        (github.event.inputs.platform == 'all' && needs.build-windows.result == 'success' && needs.build-macos.result == 'success') ||
        (github.event.inputs.platform == null && (needs.build-windows.result == 'success' || needs.build-macos.result == 'success'))
      )
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID || 'NOT_SET' }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY || 'NOT_SET' }}
      AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
      S3_BUCKET: ${{ secrets.S3_BUCKET || 'NOT_SET' }}
      S3_BASE_PATH: ${{ secrets.S3_BASE_PATH || 'releases' }}
    outputs:
      s3_base_url: ${{ steps.upload.outputs.s3_base_url }}

    steps:
    - name: Check AWS credentials
      if: env.AWS_ACCESS_KEY_ID != 'NOT_SET' && env.AWS_SECRET_ACCESS_KEY != 'NOT_SET' && env.S3_BUCKET != 'NOT_SET'
      run: |
        echo "=== Checking AWS S3 Configuration ==="
        echo "AWS credentials: Available"
        echo "S3 bucket: $S3_BUCKET"
        echo "AWS region: $AWS_REGION"
        echo "S3 base path: $S3_BASE_PATH"
        echo "S3 upload: Enabled"
        
        # Verify credentials
        echo ""
        echo "=== Verifying AWS Identity ==="
        if aws sts get-caller-identity; then
          echo "AWS credentials are valid"
        else
          echo "ERROR: AWS credentials are invalid"
          exit 1
        fi
        
        # Test S3 access
        echo ""
        echo "=== Testing S3 Access ==="
        if aws s3 ls s3://${S3_BUCKET}/ > /dev/null 2>&1; then
          echo "S3 bucket access: OK"
        else
          echo "ERROR: Cannot access S3 bucket"
          echo "This usually means the IAM user lacks s3:ListBucket permission"
          exit 1
        fi

    - name: S3 upload disabled notice
      if: env.AWS_ACCESS_KEY_ID == 'NOT_SET' || env.AWS_SECRET_ACCESS_KEY == 'NOT_SET' || env.S3_BUCKET == 'NOT_SET'
      run: |
        echo "=== S3 Upload Disabled ==="
        echo "AWS credentials: Not available"
        echo "S3 upload: Disabled"
        echo "Note: Set AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and S3_BUCKET secrets to enable S3 upload"

    - name: Download Windows artifacts
      if: |
        github.event.inputs.platform == 'windows' ||
        github.event.inputs.platform == 'all' ||
        github.event.inputs.platform == null
      uses: actions/download-artifact@v4
      with:
        name: eCan-Windows-${{ needs.validate-tag.outputs.version }}
        path: windows-artifacts

    - name: Download macOS amd64 artifacts
      if: |
        (github.event.inputs.platform == 'macos' ||
         github.event.inputs.platform == 'all' ||
         github.event.inputs.platform == null) &&
        (github.event.inputs.arch == 'amd64' ||
         github.event.inputs.arch == 'all' ||
         github.event.inputs.arch == null)
      uses: actions/download-artifact@v4
      with:
        name: eCan-macOS-amd64-${{ needs.validate-tag.outputs.version }}
        path: macos-artifacts
      continue-on-error: true

    - name: Download macOS aarch64 artifacts
      if: |
        (github.event.inputs.platform == 'macos' ||
         github.event.inputs.platform == 'all' ||
         github.event.inputs.platform == null) &&
        (github.event.inputs.arch == 'aarch64' ||
         github.event.inputs.arch == 'all' ||
         github.event.inputs.arch == null)
      uses: actions/download-artifact@v4
      with:
        name: eCan-macOS-aarch64-${{ needs.validate-tag.outputs.version }}
        path: macos-artifacts
      continue-on-error: true

    - name: Configure AWS credentials
      if: env.AWS_ACCESS_KEY_ID != 'NOT_SET' && env.AWS_SECRET_ACCESS_KEY != 'NOT_SET' && env.S3_BUCKET != 'NOT_SET'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Upload artifacts to S3
      if: env.AWS_ACCESS_KEY_ID != 'NOT_SET' && env.AWS_SECRET_ACCESS_KEY != 'NOT_SET' && env.S3_BUCKET != 'NOT_SET'
      id: upload
      run: |
        VERSION="${{ needs.validate-tag.outputs.version }}"
        S3_VERSION_PATH="${S3_BASE_PATH}/v${VERSION}"
        
        echo "=== Uploading artifacts to S3 ==="
        echo "S3 bucket: $S3_BUCKET"
        echo "S3 path: $S3_VERSION_PATH"
        
        # Create organized directory structure
        mkdir -p upload/{windows,macos,checksums}
        
        # Copy Windows artifacts
        if [ -d "windows-artifacts" ]; then
          echo "Copying Windows artifacts..."
          cp windows-artifacts/*.exe upload/windows/ 2>/dev/null || true
          cp windows-artifacts/*.msi upload/windows/ 2>/dev/null || true
        fi
        
        # Copy macOS artifacts
        if [ -d "macos-artifacts" ]; then
          echo "Copying macOS artifacts..."
          cp macos-artifacts/*.pkg upload/macos/ 2>/dev/null || true
          cp macos-artifacts/*.zip upload/macos/ 2>/dev/null || true
        fi
        
        # Generate SHA256 checksums
        echo "=== Generating checksums ==="
        cd upload
        find . -type f \( -name "*.exe" -o -name "*.msi" -o -name "*.pkg" -o -name "*.zip" \) -exec sha256sum {} \; > checksums/SHA256SUMS
        cat checksums/SHA256SUMS
        cd ..
        
        # Configure optional ACL flag (buckets with Object Ownership=BucketOwnerEnforced reject ACLs)
        ACL_ARGS=()
        if [ "${S3_USE_ACL:-}" = "true" ]; then
          ACL_ARGS+=(--acl public-read)
        fi

        # Upload to S3 (version-specific path only)
        echo "=== Uploading to S3 (version ${VERSION}) ==="
        aws s3 sync upload/ s3://${S3_BUCKET}/${S3_VERSION_PATH}/ \
          "${ACL_ARGS[@]}" \
          --cache-control "max-age=31536000" \
          --metadata "version=${VERSION}"
        
        # Create and upload 'latest' pointer only for tag/release builds
        IS_BRANCH="${{ needs.validate-tag.outputs.is-branch }}"
        
        if [ "$IS_BRANCH" = "false" ]; then
          echo "=== Creating 'latest' version pointer (tag/release build) ==="
          RELEASE_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          DOWNLOAD_BASE="https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/${S3_VERSION_PATH}"
          WIN_INSTALLER="${S3_VERSION_PATH}/windows/eCan-${VERSION}-windows-amd64-Setup.exe"
          WIN_PORTABLE="${S3_VERSION_PATH}/windows/eCan-${VERSION}-windows-amd64.exe"
          MAC_AMD64="${S3_VERSION_PATH}/macos/eCan-${VERSION}-macos-amd64.pkg"
          MAC_AARCH64="${S3_VERSION_PATH}/macos/eCan-${VERSION}-macos-aarch64.pkg"
          CHECKSUMS="${S3_VERSION_PATH}/checksums/SHA256SUMS"
          
          jq -n \
            --arg version "${VERSION}" \
            --arg release_date "${RELEASE_DATE}" \
            --arg download_base "${DOWNLOAD_BASE}" \
            --arg redirect_to "${S3_VERSION_PATH}" \
            --arg win_installer "${WIN_INSTALLER}" \
            --arg win_portable "${WIN_PORTABLE}" \
            --arg mac_amd64 "${MAC_AMD64}" \
            --arg mac_aarch64 "${MAC_AARCH64}" \
            --arg checksums "${CHECKSUMS}" \
            '{
              version: $version,
              release_date: $release_date,
              download_base: $download_base,
              redirect_to: $redirect_to,
              files: {
                windows: {
                  installer: $win_installer,
                  portable: $win_portable
                },
                macos: {
                  amd64: $mac_amd64,
                  aarch64: $mac_aarch64
                },
                checksums: $checksums
              }
            }' > latest.json
          
          # Upload lightweight pointer file to 'latest' (only ~1KB vs 500MB+ of artifacts)
          aws s3 cp latest.json s3://${S3_BUCKET}/${S3_BASE_PATH}/latest.json \
            --content-type "application/json" \
            --cache-control "max-age=300" \
            --metadata "version=${VERSION}" \
            "${ACL_ARGS[@]}"
          
          echo "[OK] Latest version pointer updated (${S3_BASE_PATH}/latest.json)"
          echo "   Points to: ${S3_VERSION_PATH}"
          echo "   This is a tag/release build, so 'latest' has been updated"
        else
          echo "[SKIP] Skipping 'latest' pointer update (branch build)"
          echo "   This is a branch build (version: ${VERSION})"
          echo "   Artifacts uploaded to: ${S3_VERSION_PATH}"
          echo "   'latest' pointer remains unchanged (only updated for tag/release builds)"
        fi
        
        # Set output for S3 base URL
        S3_BASE_URL="https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/${S3_VERSION_PATH}"
        S3_ACCELERATE_URL="https://${S3_BUCKET}.s3-accelerate.amazonaws.com/${S3_VERSION_PATH}"
        echo "s3_base_url=${S3_BASE_URL}" >> $GITHUB_OUTPUT
    - name: Display public download URLs in GitHub Actions Summary (visible to users)
      if: env.AWS_ACCESS_KEY_ID != 'NOT_SET' && env.AWS_SECRET_ACCESS_KEY != 'NOT_SET' && env.S3_BUCKET != 'NOT_SET'
      run: |
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Public Download URLs" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        VERSION="${{ needs.validate-tag.outputs.version }}"
        S3_VERSION_PATH="${S3_BASE_PATH}/v${VERSION}"
        S3_BASE_URL="https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/${S3_VERSION_PATH}"
        S3_ACCELERATE_URL="https://${S3_BUCKET}.s3-accelerate.amazonaws.com/${S3_VERSION_PATH}"
        IS_BRANCH="${{ needs.validate-tag.outputs.is-branch }}"
        
        # Display build type and latest pointer status
        if [ "$IS_BRANCH" = "false" ]; then
          echo "> **Release Build** - \`latest\` pointer has been updated to this version" >> $GITHUB_STEP_SUMMARY
        else
          echo "> **Branch Build** - \`latest\` pointer remains unchanged (only release builds update \`latest\`)" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Windows Downloads" >> $GITHUB_STEP_SUMMARY
        if [ -d "upload/windows" ]; then
          for file in upload/windows/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              size=$(du -h "$file" | cut -f1)
              echo "- \`${filename}\` (${size})" >> $GITHUB_STEP_SUMMARY
              echo "  \`${S3_BASE_URL}/windows/${filename}\`" >> $GITHUB_STEP_SUMMARY
            fi
          done
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### macOS Downloads" >> $GITHUB_STEP_SUMMARY
        if [ -d "upload/macos" ]; then
          for file in upload/macos/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              size=$(du -h "$file" | cut -f1)
              echo "- \`${filename}\` (${size})" >> $GITHUB_STEP_SUMMARY
              echo "  \`${S3_BASE_URL}/macos/${filename}\`" >> $GITHUB_STEP_SUMMARY
            fi
          done
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Checksums" >> $GITHUB_STEP_SUMMARY
        echo "- SHA256SUMS" >> $GITHUB_STEP_SUMMARY
        echo "  \`${S3_BASE_URL}/checksums/SHA256SUMS\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### S3 Transfer Acceleration" >> $GITHUB_STEP_SUMMARY
        echo "Use accelerated URLs for faster downloads from remote regions (requires S3 Transfer Acceleration enabled on bucket):" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        if [ -d "upload/windows" ]; then
          echo "#### Windows Accelerated Downloads" >> $GITHUB_STEP_SUMMARY
          for file in upload/windows/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "- \`${S3_ACCELERATE_URL}/windows/${filename}\`" >> $GITHUB_STEP_SUMMARY
            fi
          done
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        if [ -d "upload/macos" ]; then
          echo "#### macOS Accelerated Downloads" >> $GITHUB_STEP_SUMMARY
          for file in upload/macos/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "- \`${S3_ACCELERATE_URL}/macos/${filename}\`" >> $GITHUB_STEP_SUMMARY
            fi
          done
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        echo "#### Checksums Accelerated Downloads" >> $GITHUB_STEP_SUMMARY
        echo "- \`${S3_ACCELERATE_URL}/checksums/SHA256SUMS\`" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Complete Download Links List" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Get complete URLs without masking:**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "1. **Download from S3**: [\`DOWNLOAD-LINKS.txt\`](${S3_BASE_URL}/DOWNLOAD-LINKS.txt)" >> $GITHUB_STEP_SUMMARY
        echo "2. **Download from GitHub Artifacts**: Check the Artifacts list for this run, download \`download-links-${VERSION}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "> NOTE: This file contains all download links with complete URLs (without \`***\` masking) that can be copied directly." >> $GITHUB_STEP_SUMMARY

    - name: Display GitHub Artifacts Summary (no S3)
      if: env.AWS_ACCESS_KEY_ID == 'NOT_SET' || env.AWS_SECRET_ACCESS_KEY == 'NOT_SET' || env.S3_BUCKET == 'NOT_SET'
      run: |
        VERSION="${{ needs.validate-tag.outputs.version }}"
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Build Artifacts (S3 upload disabled)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Version: \`${VERSION}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        echo "### Windows Artifacts" >> $GITHUB_STEP_SUMMARY
        if [ -d "windows-artifacts" ]; then
          for file in windows-artifacts/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              size=$(du -h "$file" | cut -f1)
              echo "- \`${filename}\` (${size})" >> $GITHUB_STEP_SUMMARY
            fi
          done
        else
          echo "- (none)" >> $GITHUB_STEP_SUMMARY
        fi

        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### macOS Artifacts" >> $GITHUB_STEP_SUMMARY
        if [ -d "macos-artifacts" ]; then
          for file in macos-artifacts/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              size=$(du -h "$file" | cut -f1)
              echo "- \`${filename}\` (${size})" >> $GITHUB_STEP_SUMMARY
            fi
          done
        else
          echo "- (none)" >> $GITHUB_STEP_SUMMARY
        fi

        echo "" >> $GITHUB_STEP_SUMMARY
        echo "> S3 upload disabled: AWS credentials or S3_BUCKET not set. You can download build artifacts from the Artifacts list of this run." >> $GITHUB_STEP_SUMMARY
        
        echo ""
        echo "================================================================"
        echo "                S3 Upload Completed Successfully!"
        echo "================================================================"
        echo ""
        echo "Version: ${VERSION}"
        echo "S3 Path: s3://${S3_BUCKET}/${S3_VERSION_PATH}"
        echo ""
        if [ "$IS_BRANCH" = "false" ]; then
          echo "Build Type: [Release] Tag/Release Build"
          echo "Latest Pointer: Updated to this version"
        else
          echo "Build Type: [Branch] Branch Build"
          echo "Latest Pointer: Not updated (remains at last release)"
        fi
        echo ""
        
        # List all uploaded files with their details
        echo "Uploaded Files:"
        echo "----------------------------------------------------------------"
        
        # Find and display all uploaded files with sizes
        if [ -d "upload/windows" ]; then
          echo ""
          echo "Windows Artifacts:"
          for file in upload/windows/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              size=$(du -h "$file" | cut -f1)
              echo "   $filename ($size)"
            fi
          done
        fi
        
        if [ -d "upload/macos" ]; then
          echo ""
          echo "macOS Artifacts:"
          for file in upload/macos/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              size=$(du -h "$file" | cut -f1)
              echo "   $filename ($size)"
            fi
          done
        fi
        
        if [ -d "upload/checksums" ]; then
          echo ""
          echo "Checksums:"
          for file in upload/checksums/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "   $filename"
            fi
          done
        fi
        
        echo ""
        echo "================================================================"
        echo "                    Download URLs"
        echo "================================================================"
        echo ""
        echo "Standard S3 URLs (Global):"
        echo "----------------------------------------------------------------"
        echo ""
        
        # Windows URLs
        if [ -d "upload/windows" ]; then
          echo "Windows:"
          for file in upload/windows/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "   ${S3_BASE_URL}/windows/${filename}"
            fi
          done
          echo ""
        fi
        
        # macOS URLs
        if [ -d "upload/macos" ]; then
          echo "macOS:"
          for file in upload/macos/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "   ${S3_BASE_URL}/macos/${filename}"
            fi
          done
          echo ""
        fi
        
        # Checksums
        echo "Checksums:"
        echo "   ${S3_BASE_URL}/checksums/SHA256SUMS"
        echo ""
        
        echo "================================================================"
        echo "S3 Transfer Acceleration URLs (Faster)"
        echo "================================================================"
        echo ""
        echo "Use these URLs for faster downloads from distant regions"
        echo "   (Requires S3 Transfer Acceleration enabled on bucket)"
        echo ""
        
        # Windows Accelerated URLs
        if [ -d "upload/windows" ]; then
          echo "Windows:"
          for file in upload/windows/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "   ${S3_ACCELERATE_URL}/windows/${filename}"
            fi
          done
          echo ""
        fi
        
        # macOS Accelerated URLs
        if [ -d "upload/macos" ]; then
          echo "macOS:"
          for file in upload/macos/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "   ${S3_ACCELERATE_URL}/macos/${filename}"
            fi
          done
          echo ""
        fi
        
        # Checksums Accelerated
        echo "Checksums:"
        echo "   ${S3_ACCELERATE_URL}/checksums/SHA256SUMS"
        echo ""
        
        echo "================================================================"
        echo "                  Latest Version Pointer"
        echo "================================================================"
        echo ""
        echo "Latest Version Info:"
        echo "   https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/${S3_BASE_PATH}/latest.json"
        echo ""
        if [ "$IS_BRANCH" = "false" ]; then
          echo "   [OK] This file has been updated to point to v${VERSION}"
        else
          echo "   [SKIP] This file was NOT updated (branch build)"
          echo "   [INFO] Latest still points to the last official release"
        fi
        echo ""
        
        echo "================================================================"
        echo "Upload Summary"
        echo "================================================================"
        echo ""
        echo "All artifacts uploaded successfully"
        echo "Version: ${VERSION}"
        echo "Total files: $(find upload -type f | wc -l)"
        echo "Total size: $(du -sh upload | cut -f1)"
        echo "S3 Path: s3://${S3_BUCKET}/${S3_VERSION_PATH}"
        echo ""
        echo "================================================================"
        
        # Create download links file (unmasked URLs for easy access)
        echo "=== Creating download links file ==="
        {
          echo "eCan AI Assistant v${VERSION} - Download Links"
          echo "================================================================"
          echo ""
          echo "Standard S3 URLs:"
          echo "----------------------------------------------------------------"
          echo "Windows Installer:"
          echo "${S3_BASE_URL}/windows/eCan-${VERSION}-windows-amd64-Setup.exe"
          echo ""
          echo "macOS Intel (x86_64):"
          echo "${S3_BASE_URL}/macos/eCan-${VERSION}-macos-amd64.pkg"
          echo ""
          echo "macOS Apple Silicon (ARM64):"
          echo "${S3_BASE_URL}/macos/eCan-${VERSION}-macos-aarch64.pkg"
          echo ""
          echo "Checksums:"
          echo "${S3_BASE_URL}/checksums/SHA256SUMS"
          echo ""
          echo "================================================================"
          echo "S3 Transfer Acceleration URLs (Faster for remote regions):"
          echo "----------------------------------------------------------------"
          echo "Windows Installer:"
          echo "${S3_ACCELERATE_URL}/windows/eCan-${VERSION}-windows-amd64-Setup.exe"
          echo ""
          echo "macOS Intel (x86_64):"
          echo "${S3_ACCELERATE_URL}/macos/eCan-${VERSION}-macos-amd64.pkg"
          echo ""
          echo "macOS Apple Silicon (ARM64):"
          echo "${S3_ACCELERATE_URL}/macos/eCan-${VERSION}-macos-aarch64.pkg"
          echo ""
          echo "Checksums:"
          echo "${S3_ACCELERATE_URL}/checksums/SHA256SUMS"
          echo ""
          echo "================================================================"
          echo "Latest Version Pointer:"
          echo "https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/${S3_BASE_PATH}/latest.json"
          echo ""
          echo "================================================================"
          echo "Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "Build Type: $([ "$IS_BRANCH" = "false" ] && echo "Release" || echo "Branch")"
          echo "================================================================"
        } > download-links.txt
        
        # Upload download links file to S3
        aws s3 cp download-links.txt s3://${S3_BUCKET}/${S3_VERSION_PATH}/DOWNLOAD-LINKS.txt \
          "${ACL_ARGS[@]}" \
          --content-type "text/plain; charset=utf-8" \
          --cache-control "max-age=31536000"
        
        echo ""
        echo "[OK] Download links file created and uploaded"
        echo "   Access at: ${S3_BASE_URL}/DOWNLOAD-LINKS.txt"
        echo ""
        
        # Display download links in console (formatted to avoid secret masking)
        echo "================================================================"
        echo "COPY-PASTE DOWNLOAD LINKS (Unmasked)"
        echo "================================================================"
        cat download-links.txt
        echo "================================================================"

    - name: Upload download links as artifact
      if: env.AWS_ACCESS_KEY_ID != 'NOT_SET' && env.AWS_SECRET_ACCESS_KEY != 'NOT_SET' && env.S3_BUCKET != 'NOT_SET'
      uses: actions/upload-artifact@v4
      with:
        name: download-links-${{ needs.validate-tag.outputs.version }}
        path: download-links.txt
        retention-days: 90
        if-no-files-found: error

    - name: Create version metadata
      run: |
        VERSION="${{ needs.validate-tag.outputs.version }}"
        S3_VERSION_PATH="${S3_BASE_PATH}/v${VERSION}"
        
        # Create metadata JSON using jq
        RELEASE_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        jq -n \
          --arg version "${VERSION}" \
          --arg release_date "${RELEASE_DATE}" \
          --arg tag "v${VERSION}" \
          --argjson is_branch ${{ needs.validate-tag.outputs.is-branch }} \
          --arg ref_name "${{ needs.validate-tag.outputs.ref-name }}" \
          --arg s3_base_url "${{ steps.upload.outputs.s3_base_url }}" \
          '{
            version: $version,
            release_date: $release_date,
            tag: $tag,
            is_branch: $is_branch,
            ref_name: $ref_name,
            s3_base_url: $s3_base_url,
            files: {
              windows: [],
              macos: []
            }
          }' > version-metadata.json
        
        # Add Windows files to metadata
        if [ -d "upload/windows" ]; then
          for file in upload/windows/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file")
              jq ".files.windows += [{\"name\": \"$filename\", \"size\": $size, \"url\": \"${{ steps.upload.outputs.s3_base_url }}/windows/$filename\"}]" version-metadata.json > tmp.json && mv tmp.json version-metadata.json
            fi
          done
        fi
        
        # Add macOS files to metadata
        if [ -d "upload/macos" ]; then
          for file in upload/macos/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file")
              jq ".files.macos += [{\"name\": \"$filename\", \"size\": $size, \"url\": \"${{ steps.upload.outputs.s3_base_url }}/macos/$filename\"}]" version-metadata.json > tmp.json && mv tmp.json version-metadata.json
            fi
          done
        fi
        
        # Upload metadata to S3
        ACL_ARGS=()
        if [ "${S3_USE_ACL:-}" = "true" ]; then
          ACL_ARGS+=(--acl public-read)
        fi

        aws s3 cp version-metadata.json s3://${S3_BUCKET}/${S3_VERSION_PATH}/version-metadata.json \
          "${ACL_ARGS[@]}" \
          --content-type "application/json"
        
        echo "Version metadata uploaded to: ${{ steps.upload.outputs.s3_base_url }}/version-metadata.json"

    - name: Clean up artifacts after successful S3 upload
      run: |
        echo "=== Cleaning up local artifacts after S3 upload ==="
        
        # Calculate total size before cleanup
        TOTAL_SIZE=0
        if [ -d "upload" ]; then
          UPLOAD_SIZE=$(du -sh upload 2>/dev/null | cut -f1)
          echo "Upload directory size: $UPLOAD_SIZE"
        fi
        if [ -d "windows-artifacts" ]; then
          WIN_SIZE=$(du -sh windows-artifacts 2>/dev/null | cut -f1)
          echo "Windows artifacts size: $WIN_SIZE"
        fi
        if [ -d "macos-artifacts" ]; then
          MAC_SIZE=$(du -sh macos-artifacts 2>/dev/null | cut -f1)
          echo "macOS artifacts size: $MAC_SIZE"
        fi
        
        # Remove artifacts (they're now safely stored in S3)
        echo ""
        echo "Removing local artifacts..."
        rm -rf upload/ windows-artifacts/ macos-artifacts/ version-metadata.json latest.json 2>/dev/null || true
        
        echo ""
        echo "[OK] Cleanup completed - all artifacts are now in S3"
        echo "   Local storage freed for GitHub Actions"
        
        # Display cleanup summary in GitHub Actions Summary
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Storage Cleanup" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "All build artifacts have been successfully uploaded to S3 and cleaned from GitHub Actions storage." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "[OK] Local temporary files have been deleted, saving GitHub Actions storage space" >> $GITHUB_STEP_SUMMARY

  # Create Release (optional, for GitHub releases)
  create-release:
    needs: [validate-tag, upload-to-s3]
    if: |
      needs.validate-tag.outputs.tag-valid == 'true' &&
      startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest

    steps:
    - name: Download Windows artifacts
      if: |
        github.event.inputs.platform == 'windows' ||
        github.event.inputs.platform == 'all' ||
        github.event.inputs.platform == null
      uses: actions/download-artifact@v4
      with:
        name: eCan-Windows-${{ needs.validate-tag.outputs.version }}
        path: windows-artifacts

    - name: Download macOS amd64 artifacts
      if: |
        (github.event.inputs.platform == 'macos' ||
         github.event.inputs.platform == 'all' ||
         github.event.inputs.platform == null) &&
        (github.event.inputs.arch == 'amd64' ||
         github.event.inputs.arch == 'all' ||
         github.event.inputs.arch == null)
      uses: actions/download-artifact@v4
      with:
        name: eCan-macOS-amd64-${{ needs.validate-tag.outputs.version }}
        path: macos-artifacts
      continue-on-error: true

    - name: Download macOS aarch64 artifacts
      if: |
        (github.event.inputs.platform == 'macos' ||
         github.event.inputs.platform == 'all' ||
         github.event.inputs.platform == null) &&
        (github.event.inputs.arch == 'aarch64' ||
         github.event.inputs.arch == 'all' ||
         github.event.inputs.arch == null)
      uses: actions/download-artifact@v4
      with:
        name: eCan-macOS-aarch64-${{ needs.validate-tag.outputs.version }}
        path: macos-artifacts
      continue-on-error: true

    - name: Prepare release files list
      id: prep_files
      run: |
        echo "Listing downloaded artifacts..."
        ls -la windows-artifacts || true
        ls -la macos-artifacts || true
        echo "files<<EOF" >> $GITHUB_OUTPUT
        if ls windows-artifacts/*.exe 1> /dev/null 2>&1; then
          for f in windows-artifacts/*.exe; do echo "$f" >> $GITHUB_OUTPUT; done
        fi
        if ls macos-artifacts/*.pkg 1> /dev/null 2>&1; then
          for f in macos-artifacts/*.pkg; do echo "$f" >> $GITHUB_OUTPUT; done
        fi
        if ls macos-artifacts/*.zip 1> /dev/null 2>&1; then
          for f in macos-artifacts/*.zip; do echo "$f" >> $GITHUB_OUTPUT; done
        fi
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: ${{ steps.prep_files.outputs.files }}
        name: "eCan AI Assistant v${{ needs.validate-tag.outputs.version }}"
        body: |
          # eCan AI Assistant v${{ needs.validate-tag.outputs.version }}
          
          ##  New Release
          
          This is the latest version of eCan AI Assistant with new features and improvements.
          
          ##  Download Links (AWS S3)
          
          **Primary Download Location**: [AWS S3](${{ needs.upload-to-s3.outputs.s3_base_url }})
          
          ### Windows Users
          - **Installer**: [${{ needs.upload-to-s3.outputs.s3_base_url }}/windows/eCan-${{ needs.validate-tag.outputs.version }}-windows-amd64-Setup.exe](${{ needs.upload-to-s3.outputs.s3_base_url }}/windows/eCan-${{ needs.validate-tag.outputs.version }}-windows-amd64-Setup.exe) (Recommended)
          - **Portable**: [${{ needs.upload-to-s3.outputs.s3_base_url }}/windows/eCan-${{ needs.validate-tag.outputs.version }}-windows-amd64.exe](${{ needs.upload-to-s3.outputs.s3_base_url }}/windows/eCan-${{ needs.validate-tag.outputs.version }}-windows-amd64.exe)
          
          ### macOS Users
          - **PKG Installer (Intel)**: [${{ needs.upload-to-s3.outputs.s3_base_url }}/macos/eCan-${{ needs.validate-tag.outputs.version }}-macos-amd64.pkg](${{ needs.upload-to-s3.outputs.s3_base_url }}/macos/eCan-${{ needs.validate-tag.outputs.version }}-macos-amd64.pkg)
          - **PKG Installer (Apple Silicon)**: [${{ needs.upload-to-s3.outputs.s3_base_url }}/macos/eCan-${{ needs.validate-tag.outputs.version }}-macos-aarch64.pkg](${{ needs.upload-to-s3.outputs.s3_base_url }}/macos/eCan-${{ needs.validate-tag.outputs.version }}-macos-aarch64.pkg)
          
          ### Checksums
          - **SHA256SUMS**: [${{ needs.upload-to-s3.outputs.s3_base_url }}/checksums/SHA256SUMS](${{ needs.upload-to-s3.outputs.s3_base_url }}/checksums/SHA256SUMS)
          
          ##  Installation Instructions
          
          ### Windows
          1. Download the `eCan-*-Setup.exe` installer from S3
          2. Run the installer and follow the prompts to complete installation
          3. Launch the application from Start Menu or desktop shortcut
          
          ### macOS
          1. Download the `.pkg` installer package from S3
          2. Double-click the package and follow the prompts to complete installation
          3. Launch eCan from the Applications folder
          
          ##  System Requirements
          - **Windows**: Windows 10 or later
          - **macOS**: macOS 11.0 or later
          
          ##  Changelog
          Please see [CHANGELOG.md](CHANGELOG.md) for detailed update information.
          
          ##  Issue Reporting
          If you encounter any issues, please submit feedback on the [Issues](https://github.com/scszcoder/ecbot/issues) page.
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Generate and publish appcast using S3 URLs (only for tag/release builds)
  publish-appcast:
    needs: [validate-tag, upload-to-s3]
    # Only generate appcast for tag/release builds (branch builds don't need OTA updates)
    # Run even if upload-to-s3 was skipped, as long as it's a tag/release build
    if: |
      always() &&
      needs.validate-tag.outputs.tag-valid == 'true' &&
      needs.validate-tag.outputs.is-branch == 'false' &&
      (needs.upload-to-s3.result == 'success' || needs.upload-to-s3.result == 'skipped')
    runs-on: ubuntu-latest
    env:
      ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY || 'NOT_SET' }}
      S3_BASE_URL: ${{ needs.upload-to-s3.outputs.s3_base_url || '' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.ref || github.ref }}
          fetch-depth: 0

      - name: Check environment variables
        run: |
          echo "=== Checking Appcast Generation Environment ==="
          echo ""
          echo "NOTE: Appcast generation only runs for tag/release builds"
          echo "   - Tag/Release builds: Generate appcast for OTA updates"
          echo "   - Branch builds: Skip (development versions don't need OTA)"
          echo "   - This ensures appcast and latest.json stay in sync"
          echo ""
          if [ "${ED25519_PRIVATE_KEY}" != "NOT_SET" ]; then
            echo "ED25519_PRIVATE_KEY: Available - Appcast generation enabled"
          else
            echo "ED25519_PRIVATE_KEY: Not available - Appcast generation disabled"
          fi
          echo ""
          if [ -z "${S3_BASE_URL}" ] || [ "${S3_BASE_URL}" = "" ]; then
            echo "[WARN] S3_BASE_URL: Not available (upload-to-s3 may have been skipped)"
            echo "   Appcast generation will be skipped if S3_BASE_URL is required"
          else
            echo "[OK] S3_BASE_URL: ${S3_BASE_URL}"
          fi
          echo ""
          echo "Version: ${{ needs.validate-tag.outputs.version }}"
          echo "Is Branch: ${{ needs.validate-tag.outputs.is-branch }}"
          echo "Upload-to-S3 Result: ${{ needs.upload-to-s3.result }}"

      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: eCan-Windows-${{ needs.validate-tag.outputs.version }}
          path: windows-artifacts

      - name: Download macOS amd64 artifacts
        uses: actions/download-artifact@v4
        with:
          name: eCan-macOS-amd64-${{ needs.validate-tag.outputs.version }}
          path: macos-artifacts
        continue-on-error: true

      - name: Download macOS aarch64 artifacts
        uses: actions/download-artifact@v4
        with:
          name: eCan-macOS-aarch64-${{ needs.validate-tag.outputs.version }}
          path: macos-artifacts
        continue-on-error: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests cryptography

      - name: Generate macOS appcast (amd64)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && env.S3_BASE_URL != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY }}
        run: |
          python - <<'PY'
          import os, glob
          from build_system.generate_appcast import main
          s3_base_url = os.environ.get('S3_BASE_URL', '')
          if not s3_base_url:
              print("[WARN] S3_BASE_URL is empty, skipping appcast generation")
              exit(0)
          assets = []
          for pat in ('macos-artifacts/*amd64*.pkg','macos-artifacts/*amd64*.zip','macos-artifacts/*x86_64*.pkg','macos-artifacts/*x86_64*.zip','macos-artifacts/*x64*.pkg','macos-artifacts/*x64*.zip'):
              for p in glob.glob(pat):
                  name = os.path.basename(p)
                  url = f"{s3_base_url}/macos/{name}"
                  size = os.path.getsize(p)
                  assets.append({'name': name, 'browser_download_url': url, 'size': size, 'local_path': p})
          release = {'tag_name': f"v${{ needs.validate-tag.outputs.version }}", 'assets': assets}
          main(release, platform_filter='macos', arch_filter='amd64', output_path='dist/appcast/appcast-macos-amd64.xml')
          PY

      - name: Generate macOS appcast (aarch64)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && env.S3_BASE_URL != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY }}
        run: |
          python - <<'PY'
          import os, glob
          from build_system.generate_appcast import main
          s3_base_url = os.environ.get('S3_BASE_URL', '')
          if not s3_base_url:
              print("[WARN] S3_BASE_URL is empty, skipping appcast generation")
              exit(0)
          assets = []
          for pat in ('macos-artifacts/*aarch64*.pkg','macos-artifacts/*aarch64*.zip','macos-artifacts/*arm64*.pkg','macos-artifacts/*arm64*.zip'):
              for p in glob.glob(pat):
                  name = os.path.basename(p)
                  url = f"{s3_base_url}/macos/{name}"
                  size = os.path.getsize(p)
                  assets.append({'name': name, 'browser_download_url': url, 'size': size, 'local_path': p})
          release = {'tag_name': f"v${{ needs.validate-tag.outputs.version }}", 'assets': assets}
          main(release, platform_filter='macos', arch_filter='aarch64', output_path='dist/appcast/appcast-macos-aarch64.xml')
          PY

      - name: Generate Windows appcast (amd64)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && env.S3_BASE_URL != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY }}
        run: |
          python - <<'PY'
          import os, glob
          from build_system.generate_appcast import main
          s3_base_url = os.environ.get('S3_BASE_URL', '')
          if not s3_base_url:
              print("[WARN] S3_BASE_URL is empty, skipping appcast generation")
              exit(0)
          assets = []
          for pat in (
              'windows-artifacts/*amd64*.exe',
              'windows-artifacts/*x86_64*.exe',
              'windows-artifacts/*x64*.exe',
              'windows-artifacts/*amd64*.msi',
              'windows-artifacts/*x86_64*.msi',
              'windows-artifacts/*x64*.msi',
          ):
              for p in glob.glob(pat):
                  name = os.path.basename(p)
                  url = f"{s3_base_url}/windows/{name}"
                  size = os.path.getsize(p)
                  assets.append({'name': name, 'browser_download_url': url, 'size': size, 'local_path': p})
          release = {'tag_name': f"v${{ needs.validate-tag.outputs.version }}", 'assets': assets}
          main(release, platform_filter='windows', arch_filter='amd64', output_path='dist/appcast/appcast-windows-amd64.xml')
          PY




      - name: Generate macOS aggregate appcast (all arches)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && env.S3_BASE_URL != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY }}
        run: |
          python - <<'PY'
          import os, glob
          from build_system.generate_appcast import main
          s3_base_url = os.environ.get('S3_BASE_URL', '')
          if not s3_base_url:
              print("[WARN] S3_BASE_URL is empty, skipping appcast generation")
              exit(0)
          assets = []
          for pat in (
              'macos-artifacts/*.pkg',
              'macos-artifacts/*.zip',
          ):
              for p in glob.glob(pat):
                  name = os.path.basename(p)
                  url = f"{s3_base_url}/macos/{name}"
                  size = os.path.getsize(p)
                  assets.append({'name': name, 'browser_download_url': url, 'size': size, 'local_path': p})
          release = {
              'tag_name': f"v${{ needs.validate-tag.outputs.version }}",
              'assets': assets,
              'body': os.environ.get('RELEASE_BODY', ''),
          }
          # No arch_filter -> aggregate all macOS entries
          main(release, platform_filter='macos', output_path='dist/appcast/appcast-macos.xml')
          PY

      - name: Generate Windows aggregate appcast (all arches)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && env.S3_BASE_URL != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY }}
        run: |
          python - <<'PY'
          import os, glob
          from build_system.generate_appcast import main
          s3_base_url = os.environ.get('S3_BASE_URL', '')
          if not s3_base_url:
              print("[WARN] S3_BASE_URL is empty, skipping appcast generation")
              exit(0)
          assets = []
          for pat in (
              'windows-artifacts/*.exe',
              'windows-artifacts/*.msi',
          ):
              for p in glob.glob(pat):
                  name = os.path.basename(p)
                  url = f"{s3_base_url}/windows/{name}"
                  size = os.path.getsize(p)
                  assets.append({'name': name, 'browser_download_url': url, 'size': size, 'local_path': p})
          release = {
              'tag_name': f"v${{ needs.validate-tag.outputs.version }}",
              'assets': assets,
              'body': os.environ.get('RELEASE_BODY', ''),
          }
          # No arch_filter -> aggregate all Windows entries
          main(release, platform_filter='windows', output_path='dist/appcast/appcast-windows.xml')
          PY

      - name: Remove empty appcast files (if any)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        run: |
          shopt -s nullglob || true
          for f in dist/appcast/*.xml; do
            if [ ! -s "$f" ]; then echo "Removing empty feed: $f"; rm -f "$f"; fi
          done

      - name: Upload appcasts to S3
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && hashFiles('dist/appcast/*.xml') != '' }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
        run: |
          if [ "$AWS_ACCESS_KEY_ID" != "" ] && [ "$S3_BUCKET" != "" ]; then
            echo "=== Uploading appcasts to S3 ==="
            aws s3 sync dist/appcast/ s3://${S3_BUCKET}/appcast/ \
              --acl public-read \
              --cache-control "max-age=300" \
              --content-type "application/xml" \
              --exclude "*" \
              --include "*.xml"
            echo "Appcasts uploaded to S3"
            echo "S3 Appcast URLs:"
            for f in dist/appcast/*.xml; do
              filename=$(basename "$f")
              echo "  https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/appcast/${filename}"
            done
          else
            echo "S3 credentials not configured, skipping S3 upload"
          fi

      - name: Publish appcasts to gh-pages
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && hashFiles('dist/appcast/*.xml') != '' }}
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: dist/appcast
          keep_files: true
          enable_jekyll: false
          user_name: github-actions[bot]
          user_email: 41898282+github-actions[bot]@users.noreply.github.com

      - name: Print appcast enclosure summary
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        run: |
          set -e
          for f in dist/appcast/*.xml; do
            echo "--- $f ---"
            # Print lines containing 'enclosure' with key attributes
            awk 'BEGIN{FS="[<> ]"} /enclosure/ {for(i=1;i<=NF;i++){if($i ~ /url=|sparkle:version=|sparkle:os=|sparkle:arch=|length=|sparkle:edSignature=/) printf("%s ", $i)} print ""}' $f || true
          done

      - name: List generated appcasts
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        run: |
          echo "=== Appcast outputs ==="
          ls -la dist/appcast || true

      - name: Show appcast URLs
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
        run: |
          # Display in GitHub Actions Summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## OTA Update Feed URLs (Appcast)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Note**: Appcast is only generated for release builds and stays in sync with \`latest.json\`" >> $GITHUB_STEP_SUMMARY
          echo "> - **Appcast XML**: Used by Sparkle/WinSparkle for OTA automatic updates" >> $GITHUB_STEP_SUMMARY
          echo "> - **latest.json**: Version metadata containing download links and version info" >> $GITHUB_STEP_SUMMARY
          echo "> - Both are synchronized on each release, pointing to the same version" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### GitHub Pages (Recommended)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **macOS (All Architectures)**: [appcast-macos.xml](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-macos.xml)" >> $GITHUB_STEP_SUMMARY
          echo "- **macOS (Intel x86_64)**: [appcast-macos-amd64.xml](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-macos-amd64.xml)" >> $GITHUB_STEP_SUMMARY
          echo "- **macOS (Apple Silicon)**: [appcast-macos-aarch64.xml](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-macos-aarch64.xml)" >> $GITHUB_STEP_SUMMARY
          echo "- **Windows (x86_64)**: [appcast-windows-amd64.xml](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-windows-amd64.xml)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "$S3_BUCKET" ] && [ "$S3_BUCKET" != "NOT_SET" ]; then
            echo "### AWS S3 (Alternative)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **macOS (All Architectures)**: https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/appcast/appcast-macos.xml" >> $GITHUB_STEP_SUMMARY
            echo "- **macOS (Intel x86_64)**: https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/appcast/appcast-macos-amd64.xml" >> $GITHUB_STEP_SUMMARY
            echo "- **macOS (Apple Silicon)**: https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/appcast/appcast-macos-aarch64.xml" >> $GITHUB_STEP_SUMMARY
            echo "- **Windows (x86_64)**: https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/appcast/appcast-windows-amd64.xml" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "> **Note**: Windows only supports x86_64 (amd64) architecture" >> $GITHUB_STEP_SUMMARY
          
          # Also display in console log
          echo "=== Appcast URLs ==="
          echo ""
          echo "GitHub Pages (Primary):"
          echo "  macOS (aggregate):  https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-macos.xml"
          echo "  Windows (aggregate): https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-windows.xml"
          echo "  macOS (amd64):      https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-macos-amd64.xml"
          echo "  macOS (aarch64):    https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-macos-aarch64.xml"
          echo "  Windows (amd64):    https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-windows-amd64.xml"
          echo ""
          if [ -n "$S3_BUCKET" ]; then
            echo "AWS S3 (Alternative):"
            echo "  macOS (aggregate):  https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/appcast/appcast-macos.xml"
            echo "  Windows (aggregate): https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/appcast/appcast-windows.xml"
            echo "  macOS (amd64):      https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/appcast/appcast-macos-amd64.xml"
            echo "  macOS (aarch64):    https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/appcast/appcast-macos-aarch64.xml"
            echo "  Windows (amd64):    https://${S3_BUCKET}.s3.${AWS_REGION}.amazonaws.com/appcast/appcast-windows-amd64.xml"
          fi
          echo ""
          echo "Note: Windows only supports amd64 architecture"

      - name: Final status summary
        env:
          S3_BASE_URL: ${{ needs.upload-to-s3.outputs.s3_base_url }}
        run: |
          echo ""
          echo "================================================================"
          echo "Build and Release Completed!"
          echo "================================================================"
          echo ""
          echo "Version: ${{ needs.validate-tag.outputs.version }}"
          echo ""
          echo "Status Check:"
          echo "  - ED25519_PRIVATE_KEY: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && 'Configured' || 'Not Configured' }}"
          echo "  - Appcast Generation: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && 'Enabled' || 'Disabled' }}"
          echo "  - OTA Updates: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && 'Available' || 'Not Available' }}"
          echo ""
          if [ -n "${S3_BASE_URL}" ]; then
            echo "Download URLs:"
            echo "  S3: ${S3_BASE_URL}"
            echo "  GitHub Pages: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-macos.xml"
          fi
          echo ""
          echo "================================================================"

      - name: Clean up artifacts after appcast generation
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        run: |
          echo "=== Cleaning up artifacts after appcast generation ==="
          
          # Calculate size before cleanup
          if [ -d "windows-artifacts" ]; then
            WIN_SIZE=$(du -sh windows-artifacts 2>/dev/null | cut -f1)
            echo "Windows artifacts size: $WIN_SIZE"
          fi
          if [ -d "macos-artifacts" ]; then
            MAC_SIZE=$(du -sh macos-artifacts 2>/dev/null | cut -f1)
            echo "macOS artifacts size: $MAC_SIZE"
          fi
          if [ -d "dist/appcast" ]; then
            APPCAST_SIZE=$(du -sh dist/appcast 2>/dev/null | cut -f1)
            echo "Appcast files size: $APPCAST_SIZE"
          fi
          
          # Clean up downloaded artifacts (appcasts are already uploaded to S3 and gh-pages)
          echo ""
          echo "Removing local artifacts..."
          rm -rf windows-artifacts/ macos-artifacts/ 2>/dev/null || true
          
          echo ""
          echo "[OK] Cleanup completed - appcast files are published to GitHub Pages and S3"
          echo "   Local storage freed for GitHub Actions"
