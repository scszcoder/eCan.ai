name: Release Build eCan
#
# Build platform, CPU architecture and reference can be selected via workflow_dispatch parameters:
#   - platform: windows, macos, all
#   - arch: amd64, aarch64
#   - ref: Can fill in tag (like v1.2.3) or branch name (default current branch), editable
#
# Notes:
#   - Windows only supports amd64 architecture (GitHub Actions has no ARM64 runner)
#   - macOS supports amd64/aarch64, but GitHub Actions x86_64 runner needs special handling for arm64 builds
#
# Examples:
#   - When manually triggering workflow, you can select platform and architecture, and edit ref
#   - When pushing tag or publishing release, automatically triggered, default build all + amd64

on:
  # Trigger conditions: create tag or release
  # push:
  #   tags:
  #     - 'v*'  # Match formats like v1.0.0, v2.1.3
  # release:
  #   types: [published, edited, created]
  # Manual trigger
  workflow_dispatch:
    inputs:
      platform:
        description: 'Build platform (windows, macos, all)'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - windows
          - macos
      arch:
        description: 'CPU architecture (macOS: amd64/aarch64, Windows: amd64 only)'
        required: true
        default: 'amd64'
        type: choice
        options:
          - amd64
          - aarch64
      ref:
        description: 'Git ref to build (tag like v1.2.3 or branch name)'
        required: true
        default: ''
        type: string

jobs:
  # Validate ref (tags produce semantic version; branches get fallback version)
  validate-tag:
    runs-on: ubuntu-latest
    outputs:
      tag-valid: ${{ steps.validate.outputs.valid }}
      version: ${{ steps.validate.outputs.version }}
      is-branch: ${{ steps.validate.outputs.is_branch }}
      ref-name: ${{ steps.validate.outputs.ref_name }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.ref || github.ref }}

    - name: Validate ref and compute version
      id: validate
      shell: bash
      run: |
        set -euo pipefail
        INPUT_REF="${{ github.event.inputs.ref }}"
        REF_FULL="${GITHUB_REF}"
        if [ -n "$INPUT_REF" ]; then
          REF_NAME="$INPUT_REF"
        else
          REF_NAME="${REF_FULL#refs/*/}"
        fi
        echo "ref_name=$REF_NAME" >> $GITHUB_OUTPUT

        if [[ "$REF_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9.-]+)?(\+[A-Za-z0-9.-]+)?$ ]]; then
          echo "valid=true" >> $GITHUB_OUTPUT
          echo "is_branch=false" >> $GITHUB_OUTPUT
          echo "version=${REF_NAME#v}" >> $GITHUB_OUTPUT
          echo "Tag detected: $REF_NAME"
        else
          # Treat as branch; create fallback version 0.0.0-<branch>-<shortsha>
          SHORT_SHA=$(git rev-parse --short HEAD)
          SAFE_BRANCH=$(echo "$REF_NAME" | tr '/' '-')
          FALLBACK="0.0.0-${SAFE_BRANCH}-${SHORT_SHA}"
          echo "valid=true" >> $GITHUB_OUTPUT
          echo "is_branch=true" >> $GITHUB_OUTPUT
          echo "version=$FALLBACK" >> $GITHUB_OUTPUT
          echo "Branch detected: $REF_NAME -> version=$FALLBACK"
        fi

  # Windows build
  # Note: Windows only supports amd64 architecture, aarch64 architecture will be automatically skipped
  build-windows:
    needs: validate-tag
    if: |
      needs.validate-tag.outputs.tag-valid == 'true' &&
      (github.event.inputs.platform == 'windows' ||
       github.event.inputs.platform == 'all' ||
       github.event.inputs.platform == null) &&
      (github.event.inputs.arch == 'amd64' || github.event.inputs.arch == null) &&
      github.event.inputs.arch != 'aarch64'
    runs-on: windows-latest
    env:
      # Expose secrets to env for conditional checks without referencing `secrets` in `if:`
      WIN_CERT_PFX: ${{ secrets.WIN_CERT_PFX || 'NOT_SET' }}
      WIN_CERT_PASSWORD: ${{ secrets.WIN_CERT_PASSWORD || 'NOT_SET' }}
    timeout-minutes: 45

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: windows-pip-3.11-${{ hashFiles('requirements*.txt') }}
        restore-keys: |
          windows-pip-3.11-

    - name: Create and activate venv (Windows)
      run: |
        echo "=== Creating Virtual Environment ==="
        python -m venv .venv
        # Make venv's Python first in PATH for subsequent steps
        echo "$PWD\.venv\Scripts" >> $env:GITHUB_PATH

    - name: Install Python dependencies
      run: |
        echo "=== Python/Pip Info (Windows venv) ==="
        python -c "import sys; print(sys.version); print(sys.executable)"
        python -m pip -V

        echo "=== Installing Python Dependencies ==="
        python -m pip install --upgrade pip
        python -m pip install -r requirements-windows.txt
        python -m pip install pyinstaller==6.15.0 pywin32-ctypes
        # Ensure pywin32 is present in the same interpreter
        python -m pip install -U pywin32
        # Rarely needed but safe; registers COM bits
        python -m pywin32_postinstall -install

        echo "=== Verifying pywin32 installation ==="
        python -c "import win32api; print('pywin32 installed successfully')"

    - name: Uninstall pathlib if present (Windows)
      run: |
        python -m pip uninstall -y pathlib; if ($LASTEXITCODE -ne 0) { Write-Host "pathlib not found or already uninstalled" }

    - name: Install frontend dependencies
      run: |
        echo "=== Installing Frontend Dependencies ==="
        cd gui_v2
        npm install --legacy-peer-deps

    - name: Install Inno Setup
      run: |
        echo "=== Installing Inno Setup ==="
        $DownloadUrl = "https://files.jrsoftware.org/is/6/innosetup-6.2.2.exe"
        $DownloadPath = "$env:TEMP\innosetup-6.2.2.exe"

        Write-Host "Downloading Inno Setup..."
        Invoke-WebRequest -Uri $DownloadUrl -OutFile $DownloadPath -UseBasicParsing

        Write-Host "Installing Inno Setup..."
        Start-Process -FilePath $DownloadPath -ArgumentList "/SILENT", "/SUPPRESSMSGBOXES", "/NORESTART" -Wait

        Write-Host "Inno Setup installation completed"

        # Verify installation
        $innoPath = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
        if (Test-Path $innoPath) {
            Write-Host "Inno Setup verified at: $innoPath"
        } else {
            Write-Host "ERROR: Inno Setup not found at expected location"
            exit 1
        }

    - name: Install OTA dependencies (including winSparkle)
      run: |
        echo "=== Installing OTA Dependencies ==="
        python scripts/install_ota_dependencies.py install --platform windows

        echo "=== Verifying OTA Dependencies ==="
        python scripts/install_ota_dependencies.py verify

        echo "=== Checking winSparkle Installation ==="
        $dllPaths = @(
          "ota/dependencies/lib/winsparkle.dll",
          "ota/dependencies/winsparkle/winsparkle.dll"
        )
        $found = $false
        foreach ($p in $dllPaths) {
          if (Test-Path $p) {
            Write-Host "winSparkle DLL found at: $p"
            $dll = Get-Item $p
            Write-Host "   Size: $([math]::Round($dll.Length / 1KB, 2)) KB"
            $found = $true
            break
          }
        }
        if (-not $found) {
          Write-Host "[WARN] winSparkle DLL not found in expected locations"
          Write-Host "Searching for winSparkle files..."
          Get-ChildItem -Path "ota" -Recurse -Filter "*sparkle*" | ForEach-Object {
            Write-Host "   Found: $($_.FullName)"
          }
        }

    - name: Create build directories
      run: |
        echo "=== Creating Build Directories ==="
        New-Item -ItemType Directory -Force -Path build, dist

    - name: Check build environment
      run: |
        echo "=== Checking Build Environment ==="
        python scripts/check_build_env.py
        
        echo "=== Checking Architecture Selection ==="
        echo "Selected architecture: ${{ github.event.inputs.arch || 'amd64 (default)' }}"
        echo "Platform: ${{ github.event.inputs.platform || 'all (default)' }}"
        echo "Note: Windows only supports amd64 architecture"
        
        echo "=== Checking Windows Environment Variables ==="
        if [ "${{ env.WIN_CERT_PFX }}" != "NOT_SET" ]; then
          echo "WIN_CERT_PFX: Set"
        else
          echo "WIN_CERT_PFX: Not set"
        fi
        if [ "${{ env.WIN_CERT_PASSWORD }}" != "NOT_SET" ]; then
          echo "WIN_CERT_PASSWORD: Set"
        else
          echo "WIN_CERT_PASSWORD: Not set"
        fi

    - name: Build Windows EXE
      run: |
        echo "=== Starting Windows Build ==="
        echo "Command: python build.py prod"

        # Set environment variables
        $env:PYTHONPATH = "$PWD"
        $env:PYTHONUNBUFFERED = "1"

        # Set environment variable for build architecture
        $env:BUILD_ARCH = "amd64"

        # Run build with detailed output (including Sparkle support)
        python build.py prod --version ${{ needs.validate-tag.outputs.version }} --enable-sparkle --verify-sparkle 2>&1 | Tee-Object -FilePath "build.log"

        # Check if build succeeded by verifying key files exist
        $buildSuccess = $true
        $srcExe = "dist/eCan/eCan.exe"
        if (!(Test-Path $srcExe)) {
            echo "[ERROR] Build failed - main executable not found: $srcExe"
            $buildSuccess = $false
        }

        # Check for standardized artifacts (created by build.py)
        $stdExe = "dist/eCan-windows-amd64-v${{ needs.validate-tag.outputs.version }}.exe"
        $stdSetup = "dist/eCan-Setup-windows-amd64-v${{ needs.validate-tag.outputs.version }}.exe"

        if ($buildSuccess) {
            if (Test-Path $stdExe) {
                Write-Host "[OK] Standardized executable found: $stdExe"
            } else {
                Write-Host "[WARN] Standardized executable not found, creating manually..."
                if (Test-Path $srcExe) {
                    Copy-Item -LiteralPath $srcExe -Destination $stdExe -Force
                    Write-Host "Created: $stdExe"
                }
            }

            if (Test-Path $stdSetup) {
                Write-Host "[OK] Standardized installer found: $stdSetup"
            } else {
                $srcSetup = "dist/eCan-Setup.exe"
                if (Test-Path $srcSetup) {
                    Write-Host "[WARN] Standardized installer not found, creating manually..."
                    Rename-Item -LiteralPath $srcSetup -NewName (Split-Path -Leaf $stdSetup)
                    Write-Host "Created: $stdSetup"
                }
            }
        }

        if (-not $buildSuccess) {
            echo "=== Build Log ==="
            Get-Content "build.log"
            exit 1
        }

        echo "[OK] Build completed successfully"

        echo "=== Validating Build Artifacts ==="
        python build_system/build_validator.py --artifacts --version ${{ needs.validate-tag.outputs.version }} --arch amd64
        if ($LASTEXITCODE -ne 0) {
            echo "[ERROR] Build artifact validation failed"
            exit 1
        }

        echo "=== Verifying OTA artifacts in dist ==="
        $distWinSparkle = @(
          "dist/eCan/ota/dependencies/lib/winsparkle.dll",
          "dist/ota/dependencies/lib/winsparkle.dll"
        )
        $distFound = $false
        foreach ($p in $distWinSparkle) {
          if (Test-Path $p) {
            Write-Host "[OK] winSparkle DLL packaged at: $p"
            $dll = Get-Item $p
            Write-Host "   Size: $([math]::Round($dll.Length / 1KB, 2)) KB"
            $distFound = $true
            break
          }
        }
        if (-not $distFound) {
          Write-Host "[WARN] winSparkle DLL not found in dist; OTA (Windows) may be disabled"
        }


    - name: Code sign Windows artifacts (optional)
      if: ${{ env.WIN_CERT_PFX != 'NOT_SET' && env.WIN_CERT_PASSWORD != 'NOT_SET' }}
      env:
        WIN_CERT_PFX: ${{ env.WIN_CERT_PFX }}
        WIN_CERT_PASSWORD: ${{ env.WIN_CERT_PASSWORD }}
      run: |
        echo "=== Code signing Windows artifacts ==="
        echo "Certificate status: Available"
        echo "Password status: Available"
        $pfxPath = "$env:RUNNER_TEMP\codesign.pfx"
        [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:WIN_CERT_PFX))
        $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\x64\signtool.exe"
        if (-not (Test-Path $signtool)) { $signtool = "signtool.exe" }

        $files = @()
        # Sign distribution executables in top-level dist (avoid signing internal app binaries)
        $exeFiles = Get-ChildItem -Path "dist" -Filter "*.exe" -File -ErrorAction SilentlyContinue
        foreach ($ef in $exeFiles) { $files += $ef.FullName }
        # Optionally sign MSI installers if present
        $msiFiles = Get-ChildItem -Path "dist" -Filter "*.msi" -File -ErrorAction SilentlyContinue
        foreach ($mf in $msiFiles) { $files += $mf.FullName }

        foreach ($f in $files) {
          Write-Host "Signing $f"
          & $signtool sign /fd SHA256 /f $pfxPath /p $env:WIN_CERT_PASSWORD /tr http://timestamp.digicert.com /td SHA256 $f
          if ($LASTEXITCODE -ne 0) { Write-Host "Sign failed: $f"; exit 1 }
        }
        Write-Host "Windows code signing done"

    - name: Check build result
      run: |
        echo "=== Build Result Check ==="
        echo "=== Environment Variables Summary ==="
        echo "Windows Code Signing:"
        echo "  WIN_CERT_PFX: ${{ env.WIN_CERT_PFX != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  WIN_CERT_PASSWORD: ${{ env.WIN_CERT_PASSWORD != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  Status: ${{ env.WIN_CERT_PFX != 'NOT_SET' && env.WIN_CERT_PASSWORD != 'NOT_SET' && 'Ready for signing' || 'Skipping signing' }}"
        
        echo "Dist directory contents:"
        Get-ChildItem -Path "dist" -Recurse | Format-Table -AutoSize

        $exeFound = $false
        $setupFound = $false

        if (Test-Path "dist/eCan/eCan.exe") {
            $exe = Get-Item "dist/eCan/eCan.exe"
            echo "Windows EXE found: dist/eCan/eCan.exe"
            echo "   Size: $([math]::Round($exe.Length / 1MB, 2)) MB"
            echo "   Created: $($exe.CreationTime)"
            $exeFound = $true
        } else {
            echo "ERROR: Windows EXE not found"
            echo "Searching for .exe files..."
            Get-ChildItem -Path "dist" -Recurse -Filter "*.exe" | ForEach-Object {
                echo "   Found: $($_.FullName)"
            }
        }

        if (Test-Path "dist/eCan-Setup.exe") {
            $setup = Get-Item "dist/eCan-Setup.exe"
            echo "Installer found: dist/eCan-Setup.exe"
            echo "   Size: $([math]::Round($setup.Length / 1MB, 2)) MB"
            echo "   Created: $($setup.CreationTime)"
            $setupFound = $true
        } else {
            echo "WARN: Installer not found"
        }

        if (-not $exeFound) {
            echo "ERROR: Build validation failed - no executable found"
            exit 1
        }

        echo "Build validation passed"

    - name: Upload Windows artifacts
      uses: actions/upload-artifact@v4
      with:
        name: eCan-Windows-${{ needs.validate-tag.outputs.version }}
        path: |
          dist/eCan-windows-amd64-v${{ needs.validate-tag.outputs.version }}.exe
          dist/eCan-Setup-windows-amd64-v${{ needs.validate-tag.outputs.version }}.exe
          dist/*.msi
          build.log
        retention-days: 30

  # macOS build
  # Note: macOS supports both amd64 and aarch64 architectures
  build-macos:
    needs: validate-tag
    if: |
      needs.validate-tag.outputs.tag-valid == 'true' &&
      (github.event.inputs.platform == 'macos' ||
       github.event.inputs.platform == 'all' ||
       github.event.inputs.platform == null)
    runs-on: macos-latest
    env:
      # Expose macOS signing/notarization secrets to env for conditional checks without referencing `secrets` in `if:`
      MAC_CERT_P12: ${{ secrets.MAC_CERT_P12 || 'NOT_SET' }}
      MAC_CERT_PASSWORD: ${{ secrets.MAC_CERT_PASSWORD || 'NOT_SET' }}
      MAC_CODESIGN_IDENTITY: ${{ secrets.MAC_CODESIGN_IDENTITY || 'NOT_SET' }}
      APPLE_ID: ${{ secrets.APPLE_ID || 'NOT_SET' }}
      APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD || 'NOT_SET' }}
      TEAM_ID: ${{ secrets.TEAM_ID || 'NOT_SET' }}
    timeout-minutes: 45

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: macos-pip-3.11-${{ hashFiles('requirements*.txt') }}
        restore-keys: |
          macos-pip-3.11-

    - name: Create and activate venv (macOS)
      run: |
        echo "=== Creating Virtual Environment ==="
        python -m venv .venv
        # Make venv's Python first in PATH for subsequent steps
        echo "$PWD/.venv/bin" >> $GITHUB_PATH

    - name: Install Python dependencies
      run: |
        echo "=== Python/Pip Info (macOS venv) ==="
        python -c "import sys; print(sys.version); print(sys.executable)"
        python -m pip -V

        echo "=== Installing Python Dependencies ==="
        python -m pip install --upgrade pip
        python -m pip install -r requirements-macos.txt
        python -m pip install pyinstaller==6.15.0

        echo "=== Verifying PyInstaller installation ==="
        python -c "import PyInstaller; print('PyInstaller installed successfully')"

    - name: Uninstall pathlib if present (macOS)
      run: |
        python -m pip uninstall -y pathlib || true

    - name: Install frontend dependencies
      run: |
        echo "=== Installing Frontend Dependencies ==="
        cd gui_v2
        npm install --legacy-peer-deps

    - name: Install OTA dependencies (including Sparkle)
      run: |
        echo "=== Installing OTA Dependencies ==="
        python scripts/install_ota_dependencies.py install --platform darwin

        echo "=== Verifying OTA Dependencies ==="
        python scripts/install_ota_dependencies.py verify

        echo "=== Checking Sparkle Framework Installation ==="
        if [ -d "ota/dependencies/Sparkle.framework" ]; then
          echo "[OK] Sparkle.framework found"
          framework_size=$(du -sh ota/dependencies/Sparkle.framework | cut -f1)
          echo "   Size: $framework_size"

          # Check framework structure
          if [ -f "ota/dependencies/Sparkle.framework/Versions/Current/Sparkle" ]; then
            echo "[OK] Sparkle binary found in framework"
          else
            echo "[WARN] Sparkle binary not found in expected location"
          fi

          if [ -f "ota/dependencies/Sparkle.framework/Versions/Current/Resources/sparkle-cli" ]; then
            echo "[OK] Sparkle CLI found"
          else
            echo "[WARN] Sparkle CLI not found"
          fi
        else
          echo "[ERROR] Sparkle.framework not found"
          echo "Searching for Sparkle files..."
          find ota -name "*parkle*" -type f 2>/dev/null || echo "No Sparkle files found"
        fi

    - name: Create build directories
      run: |
        echo "=== Creating Build Directories ==="
        mkdir -p build dist

    - name: Check build environment
      run: |
        echo "=== Checking Build Environment ==="
        python scripts/check_build_env.py
        
        echo "=== Checking Architecture Selection ==="
        echo "Selected architecture: ${{ github.event.inputs.arch || 'amd64 (default)' }}"
        echo "Platform: ${{ github.event.inputs.platform || 'all (default)' }}"
        echo "Note: macOS supports both amd64 and aarch64 architectures"
        
        echo "=== Checking macOS Environment Variables ==="
        if [ "${{ env.MAC_CERT_P12 }}" != "NOT_SET" ]; then
          echo "MAC_CERT_P12: Set"
        else
          echo "MAC_CERT_P12: Not set"
        fi
        if [ "${{ env.MAC_CERT_PASSWORD }}" != "NOT_SET" ]; then
          echo "MAC_CERT_PASSWORD: Set"
        else
          echo "MAC_CERT_PASSWORD: Not set"
        fi
        if [ "${{ env.MAC_CODESIGN_IDENTITY }}" != "NOT_SET" ]; then
          echo "MAC_CODESIGN_IDENTITY: Set"
        else
          echo "MAC_CODESIGN_IDENTITY: Not set"
        fi

    - name: Build macOS App
      run: |
        echo "=== Starting macOS Build ==="
        echo "Command: python build.py prod"

        # Set environment variables
        export PYTHONPATH="$PWD"
        export PYTHONUNBUFFERED=1
        export BUILD_ARCH="${{ github.event.inputs.arch || 'amd64' }}"

        # Run build with detailed output (including Sparkle support)
        python build.py prod --version ${{ needs.validate-tag.outputs.version }} --enable-sparkle --verify-sparkle 2>&1 | tee build.log

        # Check if build succeeded by verifying key files exist
        BUILD_SUCCESS=true
        APP_PATH="dist/eCan.app"
        if [ ! -d "$APP_PATH" ]; then
            echo "[ERROR] Build failed - app bundle not found: $APP_PATH"
            BUILD_SUCCESS=false
        fi

        # Check for standardized DMG (created by build.py)
        ARCH="${{ github.event.inputs.arch || 'amd64' }}"
        VERSION="${{ needs.validate-tag.outputs.version }}"
        STD_DMG="dist/eCan-macos-${ARCH}-v${VERSION}.dmg"

        if [ "$BUILD_SUCCESS" = "true" ]; then
            if [ -f "$STD_DMG" ]; then
                echo "[OK] Standardized DMG found: $STD_DMG"
            else
                echo "[INFO] Standardized DMG will be created in next step"
            fi
        fi

        if [ "$BUILD_SUCCESS" != "true" ]; then
            echo "=== Build Log ==="
            cat build.log
            exit 1
        fi

        echo "[OK] Build completed successfully"

    - name: Validate build artifacts
      run: |
        echo "=== Validating Build Artifacts ==="
        python build_system/build_validator.py --artifacts --version ${{ needs.validate-tag.outputs.version }} --arch ${{ github.event.inputs.arch || 'amd64' }}
        if [ $? -ne 0 ]; then
            echo "[ERROR] Build artifact validation failed"
            exit 1
        fi

    - name: Create DMG from app
      if: ${{ always() }}
      run: |
        echo "=== Creating DMG ==="
        ARCH="${{ github.event.inputs.arch || 'amd64' }}"
        VERSION="${{ needs.validate-tag.outputs.version }}"
        APP_PATH="dist/eCan.app"
        DMG_PATH="dist/eCan-macos-${ARCH}-v${VERSION}.dmg"
        if [ -d "$APP_PATH" ]; then
          mkdir -p build/dmg
          rm -rf build/dmg/*
          cp -R "$APP_PATH" build/dmg/
          hdiutil create -volname "eCan" -srcfolder build/dmg -ov -format UDZO "$DMG_PATH"
          echo "[OK] DMG created at: $DMG_PATH"
        else
          echo "[WARN] App not found at $APP_PATH; skip DMG creation"
        fi

    - name: Code sign macOS app (optional)
      if: ${{ env.MAC_CERT_P12 != 'NOT_SET' && env.MAC_CERT_PASSWORD != 'NOT_SET' && env.MAC_CODESIGN_IDENTITY != 'NOT_SET' }}
      env:
        MAC_CERT_P12: ${{ env.MAC_CERT_P12 }}
        MAC_CERT_PASSWORD: ${{ env.MAC_CERT_PASSWORD }}
        MAC_CODESIGN_IDENTITY: ${{ env.MAC_CODESIGN_IDENTITY }}
      run: |
        echo "=== Code signing macOS app (if secrets provided) ==="
        echo "Certificate status: Available"
        echo "Password status: Available"
        echo "Identity status: Available"
        if [ -z "${MAC_CERT_P12}" ] || [ -z "${MAC_CERT_PASSWORD}" ] || [ -z "${MAC_CODESIGN_IDENTITY}" ]; then
          echo "No macOS signing secrets; skip codesign"
          exit 0
        fi
        CERT_PATH="$RUNNER_TEMP/cert.p12"
        echo "$MAC_CERT_P12" | base64 --decode > "$CERT_PATH"
        KEYCHAIN=build.keychain
        KEYCHAIN_PW="actions"
        security create-keychain -p "$KEYCHAIN_PW" "$KEYCHAIN"
        security set-keychain-settings -lut 21600 "$KEYCHAIN"
        security unlock-keychain -p "$KEYCHAIN_PW" "$KEYCHAIN"
        security import "$CERT_PATH" -k "$KEYCHAIN" -P "$MAC_CERT_PASSWORD" -T /usr/bin/codesign
        security list-keychain -d user -s "$KEYCHAIN" login.keychain
        if [ -d "dist/eCan.app" ]; then
          echo "Signing dist/eCan.app"
          codesign --deep --force --options runtime --sign "$MAC_CODESIGN_IDENTITY" "dist/eCan.app"
          codesign --verify --deep --strict --verbose=2 "dist/eCan.app"
        else
          echo "dist/eCan.app not found; skip codesign"
        fi

    - name: Notarize macOS DMG (optional)
      if: ${{ env.APPLE_ID != 'NOT_SET' && env.APPLE_APP_SPECIFIC_PASSWORD != 'NOT_SET' && env.TEAM_ID != 'NOT_SET' }}
      env:
        APPLE_ID: ${{ env.APPLE_ID }}
        APPLE_APP_SPECIFIC_PASSWORD: ${{ env.APPLE_APP_SPECIFIC_PASSWORD }}
        TEAM_ID: ${{ env.TEAM_ID }}
      run: |
        echo "=== Notarize macOS DMG (if Apple credentials provided) ==="
        if [ -z "${APPLE_ID}" ] || [ -z "${APPLE_APP_SPECIFIC_PASSWORD}" ] || [ -z "${TEAM_ID}" ]; then
          echo "No Apple notarization credentials; skip notarization"
          exit 0
        fi
        ARCH="${{ github.event.inputs.arch || 'amd64' }}"
        VERSION="${{ needs.validate-tag.outputs.version }}"
        DMG_PATH="dist/eCan-macos-${ARCH}-v${VERSION}.dmg"
        if [ -f "$DMG_PATH" ]; then
          echo "Submitting $DMG_PATH for notarization..."
          xcrun notarytool submit "$DMG_PATH" --apple-id "$APPLE_ID" --password "$APPLE_APP_SPECIFIC_PASSWORD" --team-id "$TEAM_ID" --wait
          echo "[OK] Notarization completed"
        else
          echo "DMG not found, skip notarization"
        fi

    - name: Check build result
      run: |
        echo "=== Build Result Check ==="
        echo "=== Environment Variables Summary ==="
        echo "macOS Code Signing:"
        echo "  MAC_CERT_P12: ${{ env.MAC_CERT_P12 != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  MAC_CERT_PASSWORD: ${{ env.MAC_CERT_PASSWORD != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  MAC_CODESIGN_IDENTITY: ${{ env.MAC_CODESIGN_IDENTITY != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  Status: ${{ env.MAC_CERT_P12 != 'NOT_SET' && env.MAC_CERT_PASSWORD != 'NOT_SET' && env.MAC_CODESIGN_IDENTITY != 'NOT_SET' && 'Ready for signing' || 'Skipping signing' }}"
        
        echo "macOS Notarization:"
        echo "  APPLE_ID: ${{ env.APPLE_ID != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  APPLE_APP_SPECIFIC_PASSWORD: ${{ env.APPLE_APP_SPECIFIC_PASSWORD != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  TEAM_ID: ${{ env.TEAM_ID != 'NOT_SET' && 'Available' || 'Not Available' }}"
        echo "  Status: ${{ env.APPLE_ID != 'NOT_SET' && env.APPLE_APP_SPECIFIC_PASSWORD != 'NOT_SET' && env.TEAM_ID != 'NOT_SET' && 'Ready for notarization' || 'Skipping notarization' }}"
        
        echo "Dist directory contents:"
        ls -la dist/

        ARCH="${{ github.event.inputs.arch || 'amd64' }}"
        VERSION="${{ needs.validate-tag.outputs.version }}"
        DMG_PATH="dist/eCan-macos-${ARCH}-v${VERSION}.dmg"
        if [ -f "$DMG_PATH" ]; then
            echo "[OK] macOS DMG found: $DMG_PATH"
            dmg_size=$(du -sh "$DMG_PATH" | cut -f1)
            echo "   Size: $dmg_size"
        elif [ -d "dist/eCan.app" ]; then
            echo "[OK] macOS App found: dist/eCan.app"
            app_size=$(du -sh dist/eCan.app | cut -f1)
            echo "   Size: $app_size"
            echo "   App structure:"
            find dist/eCan.app -type f -name "eCan" | head -5
        else
            echo "[ERROR] macOS build not found"
            echo "Searching for .dmg and .app files..."
            find dist -name "*.dmg" 2>/dev/null || echo "No .dmg files found"
            find dist -name "*.app" 2>/dev/null || echo "No .app files found"
            exit 1
        fi

        echo "[OK] Build validation passed"

    - name: Upload macOS artifacts
      uses: actions/upload-artifact@v4
      with:
        name: eCan-macOS-${{ needs.validate-tag.outputs.version }}
        path: |
          dist/eCan-macos-*-v${{ needs.validate-tag.outputs.version }}.dmg
          build.log
        retention-days: 30

  # Create Release
  create-release:
    needs: [validate-tag, build-windows, build-macos]
    if: |
      needs.validate-tag.outputs.tag-valid == 'true' &&
      startsWith(github.ref, 'refs/tags/v') &&
      (
        (github.event.inputs.platform == 'windows' && needs.build-windows.result == 'success') ||
        (github.event.inputs.platform == 'macos' && needs.build-macos.result == 'success') ||
        (github.event.inputs.platform == 'all' && needs.build-windows.result == 'success' && needs.build-macos.result == 'success') ||
        (github.event.inputs.platform == null && needs.build-windows.result == 'success' && needs.build-macos.result == 'success')
      )
    runs-on: ubuntu-latest

    steps:
    - name: Download Windows artifacts
      if: |
        github.event.inputs.platform == 'windows' ||
        github.event.inputs.platform == 'all' ||
        github.event.inputs.platform == null
      uses: actions/download-artifact@v4
      with:
        name: eCan-Windows-${{ needs.validate-tag.outputs.version }}
        path: windows-artifacts

    - name: Download macOS artifacts
      if: |
        github.event.inputs.platform == 'macos' ||
        github.event.inputs.platform == 'all' ||
        github.event.inputs.platform == null
      uses: actions/download-artifact@v4
      with:
        name: eCan-macOS-${{ needs.validate-tag.outputs.version }}
        path: macos-artifacts

    - name: Prepare release files list
      id: prep_files
      run: |
        echo "Listing downloaded artifacts..."
        ls -la windows-artifacts || true
        ls -la macos-artifacts || true
        echo "files<<EOF" >> $GITHUB_OUTPUT
        if ls windows-artifacts/*.exe 1> /dev/null 2>&1; then
          for f in windows-artifacts/*.exe; do echo "$f" >> $GITHUB_OUTPUT; done
        fi
        if ls macos-artifacts/*.pkg 1> /dev/null 2>&1; then
          for f in macos-artifacts/*.pkg; do echo "$f" >> $GITHUB_OUTPUT; done
        fi
        if ls macos-artifacts/*.zip 1> /dev/null 2>&1; then
          for f in macos-artifacts/*.zip; do echo "$f" >> $GITHUB_OUTPUT; done
        fi
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: ${{ steps.prep_files.outputs.files }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Generate and publish appcast after Release is created (ensures final URLs and sizes)
  publish-appcast:
    needs: create-release
    runs-on: ubuntu-latest
    env:
      ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY || 'NOT_SET' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check environment variables
        run: |
          echo "=== Checking Appcast Generation Environment ==="
          if [ "${{ env.ED25519_PRIVATE_KEY }}" != "NOT_SET" ]; then
            echo "ED25519_PRIVATE_KEY: Available - Appcast generation enabled"
          else
            echo "ED25519_PRIVATE_KEY: Not available - Appcast generation disabled"
          fi

      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: eCan-Windows-${{ needs.validate-tag.outputs.version }}
          path: windows-artifacts

      - name: Download macOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: eCan-macOS-${{ needs.validate-tag.outputs.version }}
          path: macos-artifacts

      - name: Download Linux artifacts (optional)
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: eCan-Linux-${{ needs.validate-tag.outputs.version }}
          path: linux-artifacts

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests cryptography

      - name: Generate macOS appcast (amd64)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY }}
        run: |
          python - <<'PY'
          import os, glob
          from scripts.generate_appcast import main
          assets = []
          for pat in ('macos-artifacts/*amd64*.pkg','macos-artifacts/*amd64*.zip','macos-artifacts/*x86_64*.pkg','macos-artifacts/*x86_64*.zip','macos-artifacts/*x64*.pkg','macos-artifacts/*x64*.zip'):
              for p in glob.glob(pat):
                  name = os.path.basename(p)
                  url = f"https://github.com/${{ github.repository }}/releases/download/v${{ needs.validate-tag.outputs.version }}/{name}"
                  size = os.path.getsize(p)
                  assets.append({'name': name, 'browser_download_url': url, 'size': size})
          release = {'tag_name': f"v${{ needs.validate-tag.outputs.version }}", 'assets': assets}
          main(release, platform_filter='macos', arch_filter='amd64', output_path='dist/appcast/appcast-macos-amd64.xml')
          PY

      - name: Generate macOS appcast (aarch64)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY }}
        run: |
          python - <<'PY'
          import os, glob
          from scripts.generate_appcast import main
          assets = []
          for pat in ('macos-artifacts/*aarch64*.pkg','macos-artifacts/*aarch64*.zip','macos-artifacts/*arm64*.pkg','macos-artifacts/*arm64*.zip'):
              for p in glob.glob(pat):
                  name = os.path.basename(p)
                  url = f"https://github.com/${{ github.repository }}/releases/download/v${{ needs.validate-tag.outputs.version }}/{name}"
                  size = os.path.getsize(p)
                  assets.append({'name': name, 'browser_download_url': url, 'size': size})
          release = {'tag_name': f"v${{ needs.validate-tag.outputs.version }}", 'assets': assets}
          main(release, platform_filter='macos', arch_filter='aarch64', output_path='dist/appcast/appcast-macos-aarch64.xml')
          PY

      - name: Generate Windows appcast (amd64)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY }}
        run: |
          python - <<'PY'
          import os, glob
          from scripts.generate_appcast import main
          assets = []
          for pat in (
              'windows-artifacts/*amd64*.exe',
              'windows-artifacts/*x86_64*.exe',
              'windows-artifacts/*x64*.exe',
              'windows-artifacts/*amd64*.msi',
              'windows-artifacts/*x86_64*.msi',
              'windows-artifacts/*x64*.msi',
          ):
              for p in glob.glob(pat):
                  name = os.path.basename(p)
                  url = f"https://github.com/${{ github.repository }}/releases/download/v${{ needs.validate-tag.outputs.version }}/{name}"
                  size = os.path.getsize(p)
                  assets.append({'name': name, 'browser_download_url': url, 'size': size})
          release = {'tag_name': f"v${{ needs.validate-tag.outputs.version }}", 'assets': assets}
          main(release, platform_filter='windows', arch_filter='amd64', output_path='dist/appcast/appcast-windows-amd64.xml')
          PY




      - name: Generate macOS aggregate appcast (all arches)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY }}
        run: |
          python - <<'PY'
          import os, glob
          from scripts.generate_appcast import main
          assets = []
          for pat in (
              'macos-artifacts/*.pkg',
              'macos-artifacts/*.zip',
          ):
              for p in glob.glob(pat):
                  name = os.path.basename(p)
                  url = f"https://github.com/${{ github.repository }}/releases/download/v${{ needs.validate-tag.outputs.version }}/{name}"
                  size = os.path.getsize(p)
                  assets.append({'name': name, 'browser_download_url': url, 'size': size})
          release = {
              'tag_name': f"v${{ needs.validate-tag.outputs.version }}",
              'assets': assets,
              'body': os.environ.get('RELEASE_BODY', ''),
          }
          # No arch_filter -> aggregate all macOS entries
          main(release, platform_filter='macos', output_path='dist/appcast/appcast-macos.xml')
          PY

      - name: Generate Windows aggregate appcast (all arches)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ED25519_PRIVATE_KEY: ${{ secrets.ED25519_PRIVATE_KEY }}
        run: |
          python - <<'PY'
          import os, glob
          from scripts.generate_appcast import main
          assets = []
          for pat in (
              'windows-artifacts/*.exe',
              'windows-artifacts/*.msi',
          ):
              for p in glob.glob(pat):
                  name = os.path.basename(p)
                  url = f"https://github.com/${{ github.repository }}/releases/download/v${{ needs.validate-tag.outputs.version }}/{name}"
                  size = os.path.getsize(p)
                  assets.append({'name': name, 'browser_download_url': url, 'size': size})
          release = {
              'tag_name': f"v${{ needs.validate-tag.outputs.version }}",
              'assets': assets,
              'body': os.environ.get('RELEASE_BODY', ''),
          }
          # No arch_filter -> aggregate all Windows entries
          main(release, platform_filter='windows', output_path='dist/appcast/appcast-windows.xml')
          PY



      - name: Remove empty appcast files (if any)
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        run: |
          shopt -s nullglob || true
          for f in dist/appcast/*.xml; do
            if [ ! -s "$f" ]; then echo "Removing empty feed: $f"; rm -f "$f"; fi
          done

      - name: Publish appcasts to gh-pages
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && hashFiles('dist/appcast/*.xml') != '' }}
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: dist/appcast
          keep_files: true
          enable_jekyll: false
          user_name: github-actions[bot]
          user_email: 41898282+github-actions[bot]@users.noreply.github.com

      - name: Print appcast enclosure summary
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        run: |
          set -e
          for f in dist/appcast/*.xml; do
            echo "--- $f ---"
            # Print lines containing 'enclosure' with key attributes
            awk 'BEGIN{FS="[<> ]"} /enclosure/ {for(i=1;i<=NF;i++){if($i ~ /url=|sparkle:version=|sparkle:os=|sparkle:arch=|length=|sparkle:edSignature=/) printf("%s ", $i)} print ""}' $f || true
          done

      - name: List generated appcasts
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        run: |
          echo "=== Appcast outputs ==="
          ls -la dist/appcast || true

      - name: Show appcast URLs
        if: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' }}
        run: |
          echo "Appcast (macOS aggregate):  https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-macos.xml"
          echo "Appcast (Windows aggregate): https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-windows.xml"
          echo "Appcast (macOS amd64):      https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-macos-amd64.xml"
          echo "Appcast (macOS aarch64):    https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-macos-aarch64.xml"
          echo "Appcast (Windows amd64):    https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/appcast-windows-amd64.xml"
          echo "Note: Windows only supports amd64 architecture"

      - name: Final status summary
        run: |
          echo "=== Final Build Status Summary ==="
          echo "Build completed successfully!"
          echo ""
          echo "Environment Variables Status:"
          echo "  ED25519_PRIVATE_KEY: ${{ env.ED25519_PRIVATE_KEY != 'NOT_SET' && 'Available' || 'Not Available' }}"
          echo ""
          if [ "${{ env.ED25519_PRIVATE_KEY }}" != "NOT_SET" ]; then
            echo "Appcast generation: Enabled"
            echo "OTA updates: Available"
          else
            echo "Appcast generation: Disabled (ED25519_PRIVATE_KEY not set)"
            echo "OTA updates: Not available"
            echo ""
            echo "To enable OTA updates, set the ED25519_PRIVATE_KEY secret in your repository settings."
          fi
