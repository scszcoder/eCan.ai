import traceback
from typing import TYPE_CHECKING, Any, Optional, Dict
from app_context import AppContext
if TYPE_CHECKING:
    from gui.MainGUI import MainWindow
from gui.ipc.handlers import validate_params
from gui.ipc.registry import IPCHandlerRegistry
from gui.ipc.types import IPCRequest, IPCResponse, create_error_response, create_success_response
from agent.cloud_api.constants import Operation

from utils.logger_helper import logger_helper as logger


# ============================================================================
# Helper Functions for Agent Task Management
# ============================================================================

def _serialize_task_status(status) -> str:
    """Serialize TaskStatus object to a JSON-serializable string
    
    Args:
        status: TaskStatus object, string, or None
        
    Returns:
        str: Status string (e.g., 'pending', 'working', 'completed')
    """
    if status is None:
        return 'pending'
    
    # If it's already a string, return it
    if isinstance(status, str):
        return status
    
    # If it's a TaskStatus object (Pydantic model), extract the state
    if hasattr(status, 'state'):
        state = status.state
        # TaskState is an enum, get its value
        if hasattr(state, 'value'):
            return state.value
        return str(state)
    
    # Fallback: convert to string
    return str(status)


def _get_agent_task_service():
    """Get agent task service from mainwin (uses correct user-specific database path)

    Returns:
        task_service: Database agent task service instance, or None if not available
    """
    main_window = AppContext.get_main_window()
    if main_window and hasattr(main_window, 'ec_db_mgr'):
        return main_window.ec_db_mgr.task_service
    else:
        logger.error("[task_handler] mainwin.ec_db_mgr not available - cannot access database")
        return None


def _prepare_agent_task_data(agent_task_info: Dict[str, Any], username: str, agent_task_id: Optional[str] = None) -> Dict[str, Any]:
    """Prepare agent task data for database storage

    Args:
        agent_task_info: Raw agent task information from frontend
        username: Owner username
        agent_task_id: Optional agent task ID (if None, will be generated by database)

    Returns:
        Dict containing prepared agent task data
    """
    agent_task_data = {
        'name': agent_task_info.get('name', 'Unnamed Agent Task'),
        'owner': username,
        'description': agent_task_info.get('description', ''),
        'priority': agent_task_info.get('priority', 'medium'),
        'status': agent_task_info.get('status', 'pending'),
        'task_type': agent_task_info.get('task_type', ''),
        'objectives': agent_task_info.get('objectives', []),
        'schedule': agent_task_info.get('schedule', {}),
        'trigger': agent_task_info.get('trigger', 'manual'),
        'progress': agent_task_info.get('progress', 0.0),
        'result': agent_task_info.get('result', {}),
        'error_message': agent_task_info.get('error_message', ''),
        'settings': agent_task_info.get('settings', {}),
        'org_id': agent_task_info.get('org_id', None),
    }

    # Only add ID if provided (for updates)
    if agent_task_id:
        agent_task_data['id'] = agent_task_id

    return agent_task_data


def _update_agent_task_in_memory(agent_task_id: str, agent_task_data: Dict[str, Any]) -> bool:
    """Update or add agent task in mainwin.agent_tasks memory

    Args:
        agent_task_id: Agent task ID
        agent_task_data: Agent task data dictionary

    Returns:
        bool: True if successful, False otherwise
    """
    try:
        main_window = AppContext.get_main_window()
        if not main_window or not hasattr(main_window, 'agent_tasks'):
            logger.warning("[task_handler] mainwin.agent_tasks not available")
            return False

        from agent.ec_tasks import ManagedTask
        from agent.a2a.common.types import TaskStatus, TaskState

        # Check if agent task already exists in memory
        existing_index = None
        for i, agent_task in enumerate(main_window.agent_tasks or []):
            if hasattr(agent_task, 'id') and agent_task.id == agent_task_id:
                existing_index = i
                break

        # Create agent task object with all required fields
        # ManagedTask requires: id, name, status (with state), skill, state
        # Valid TaskState values: submitted, working, input-required, completed, canceled, failed, unknown
        task_status = agent_task_data.get('status', 'submitted')
        # Map common status values to valid TaskState
        status_mapping = {
            'pending': 'submitted',
            'ready': 'submitted',
            'running': 'working',
            'paused': 'input-required',
            'done': 'completed',
            'error': 'failed'
        }
        task_status = status_mapping.get(task_status, task_status)
        
        agent_task_obj = ManagedTask(
            id=agent_task_id,
            name=agent_task_data['name'],
            description=agent_task_data.get('description', ''),
            owner=agent_task_data['owner'],
            status=TaskStatus(
                state=TaskState(task_status)
            ),
            skill=agent_task_data.get('skill', ''),  # Skill name or empty string
            state={}  # Empty state dict for new tasks
        )

        if existing_index is not None:
            # Update existing agent task
            main_window.agent_tasks[existing_index] = agent_task_obj
            logger.info(f"[task_handler] Updated agent task in memory: {agent_task_data['name']}")
        else:
            # Add new agent task
            if main_window.agent_tasks is None:
                main_window.agent_tasks = []
            main_window.agent_tasks.append(agent_task_obj)
            logger.info(f"[task_handler] Added new agent task to memory: {agent_task_data['name']}")

        return True

    except Exception as e:
        logger.warning(f"[task_handler] Failed to update mainwin.agent_tasks: {e}")
        return False


def _create_clean_agent_task_response(agent_task_id: str, agent_task_data: Dict[str, Any]) -> Dict[str, Any]:
    """Create clean agent task data for response (avoid circular references)

    Args:
        agent_task_id: Agent task ID
        agent_task_data: Agent task data dictionary

    Returns:
        Dict containing clean agent task data
    """
    return {
        'id': agent_task_id,
        'name': agent_task_data['name'],
        'owner': agent_task_data['owner'],
        'description': agent_task_data['description'],
        'priority': agent_task_data.get('priority', 'medium'),
        'status': agent_task_data.get('status', 'pending'),
        'task_type': agent_task_data.get('task_type', ''),
        'progress': agent_task_data.get('progress', 0.0)
    }

@IPCHandlerRegistry.handler('get_agent_tasks')
def handle_get_agent_tasks(request: IPCRequest, params: Optional[Dict[str, Any]]) -> IPCResponse:
    """Get agent tasks list from memory

    Reads agent tasks from mainwin.agent_tasks which contains all agent tasks
    (database agent tasks + cloud agent tasks + local code agent tasks).

    Args:
        request: IPC request object
        params: Request parameters, must contain 'username' field

    Returns:
        JSON formatted response message
    """
    try:
        logger.debug(f"Get agent tasks handler called with request: {request}")

        # Validate parameters
        is_valid, data, error = validate_params(params, ['username'])
        if not is_valid:
            logger.warning(f"Invalid parameters for get agent tasks: {error}")
            return create_error_response(
                request,
                'INVALID_PARAMS',
                error
            )

        username = data['username']
        logger.info(f"Getting agent tasks for user: {username}")

        # Read agent task data directly from memory
        try:
            main_window = AppContext.get_main_window()
            memory_agent_tasks = main_window.agent_tasks or []
            logger.info(f"Found {len(memory_agent_tasks)} agent tasks in memory (mainwin.agent_tasks)")

            # Convert memory agent tasks to dictionary format
            agent_tasks_dicts = []
            for i, agent_task in enumerate(memory_agent_tasks):
                try:
                    agent_task_dict = agent_task.to_dict() if hasattr(agent_task, 'to_dict') else {
                        'id': getattr(agent_task, 'id', f'agent_task_{i}'),
                        'name': getattr(agent_task, 'name', 'Unknown Agent Task'),
                        'description': getattr(agent_task, 'description', ''),
                        'owner': username,
                        'status': _serialize_task_status(getattr(agent_task, 'status', None)),
                        'priority': getattr(agent_task, 'priority', 'medium')
                    }
                    # Ensure necessary fields exist
                    agent_task_dict['owner'] = username
                    if 'id' not in agent_task_dict:
                        agent_task_dict['id'] = f"agent_task_{i}"
                    agent_tasks_dicts.append(agent_task_dict)
                    logger.debug(f"Converted agent task: {agent_task_dict.get('name', 'NO NAME')}")
                except Exception as e:
                    logger.error(f"Failed to convert agent task {i}: {e}")

            logger.info(f"Returning {len(agent_tasks_dicts)} agent tasks to frontend")

            resultJS = {
                'tasks': agent_tasks_dicts,
                'message': 'Get agent tasks successful',
                'source': 'memory'
            }
            return create_success_response(request, resultJS)

        except Exception as e:
            logger.error(f"Failed to get agent tasks from memory: {e}")
            # Return empty list as fallback
            return create_success_response(request, {
                'tasks': [],
                'message': 'No agent tasks available',
                'source': 'empty'
            })

    except Exception as e:
        logger.error(f"Error in get agent tasks handler: {e} {traceback.format_exc()}")
        return create_error_response(
            request,
            'GET_TASKS_ERROR',
            f"Error during get agent tasks: {str(e)}"
        )
    
@IPCHandlerRegistry.handler('save_agent_task')
def handle_save_agent_task(request: IPCRequest, params: Optional[Dict[str, Any]]) -> IPCResponse:
    """Handle saving agent task to local database

    Args:
        request: IPC request object
        params: Request parameters, must contain 'username' and 'task_info' fields

    Returns:
        JSON formatted response message
    """
    try:
        logger.debug(f"Save task handler called with request: {request}")

        # Validate parameters
        is_valid, data, error = validate_params(params, ['username', 'task_info'])
        if not is_valid:
            logger.warning(f"Invalid parameters for save task: {error}")
            return create_error_response(request, 'INVALID_PARAMS', error)

        username = data['username']
        agent_task_info = data['task_info']
        agent_task_id = agent_task_info.get('id')

        if not agent_task_id:
            return create_error_response(request, 'INVALID_PARAMS', 'Agent task ID is required for save operation')

        logger.info(f"Saving agent task for user: {username}, agent_task_id: {agent_task_id}")

        # Get database service
        agent_task_service = _get_agent_task_service()
        if not agent_task_service:
            return create_error_response(request, 'SERVICE_ERROR', 'Database service not available')

        # Prepare agent task data
        agent_task_data = _prepare_agent_task_data(agent_task_info, username, agent_task_id)

        # Check if agent task exists
        existing_agent_task = agent_task_service.query_tasks(id=agent_task_id)

        if existing_agent_task.get('success') and existing_agent_task.get('data'):
            # Update existing agent task
            logger.info(f"Updating existing agent task: {agent_task_id}")
            result = agent_task_service.update_task(agent_task_id, agent_task_data)
        else:
            # Create new agent task
            logger.info(f"Creating new agent task: {agent_task_id}")
            result = agent_task_service.add_task(agent_task_data)

        if result.get('success'):
            # Get the actual agent_task_id from database response (in case it was generated)
            actual_agent_task_id = result.get('id', agent_task_id)
            logger.info(f"Agent task saved successfully: {agent_task_data['name']} (ID: {actual_agent_task_id})")

            # Step 2: Update memory after database update succeeds
            _update_agent_task_in_memory(actual_agent_task_id, agent_task_data)

            # Step 3: Clean up offline sync queue for this task (remove pending add/update operations)
            try:
                from agent.cloud_api.offline_sync_queue import get_offline_sync_queue
                sync_queue = get_offline_sync_queue()
                # Remove any pending add operations (they're now redundant since we're updating)
                removed_add = sync_queue.remove_tasks_by_resource('task', actual_agent_task_id, operation='add')
                # Remove any pending update operations (they're now redundant since we have a new update)
                removed_update = sync_queue.remove_tasks_by_resource('task', actual_agent_task_id, operation='update')
                if removed_add + removed_update > 0:
                    logger.info(f"[task_handler] Removed {removed_add + removed_update} pending sync tasks for task: {actual_agent_task_id}")
            except Exception as e:
                logger.warning(f"[task_handler] Failed to clean offline sync queue: {e}")

            # Step 4: Sync to cloud after memory update succeeds (async, fire and forget)
            task_data_with_id = agent_task_data.copy()
            task_data_with_id['id'] = actual_agent_task_id
            
            # Sync Task entity
            _trigger_cloud_sync(task_data_with_id, Operation.UPDATE)
            
            # Sync Task-Skill relationships (if changed)
            if 'skills' in agent_task_data:
                _sync_task_skill_relations(actual_agent_task_id, agent_task_data.get('skills', []), Operation.UPDATE)

            # Create clean response
            clean_agent_task_data = _create_clean_agent_task_response(actual_agent_task_id, agent_task_data)

            return create_success_response(request, {
                'message': 'Save agent task successful',
                'task_id': actual_agent_task_id,
                'data': clean_agent_task_data
            })
        else:
            logger.error(f"Failed to save agent task: {result.get('error')}")
            return create_error_response(
                request,
                'SAVE_TASK_ERROR',
                f"Failed to save agent task: {result.get('error')}"
            )

    except Exception as e:
        logger.error(f"Error in save task handler: {e} {traceback.format_exc()}")
        return create_error_response(
            request,
            'SAVE_TASK_ERROR',
            f"Error during save task: {str(e)}"
        )


@IPCHandlerRegistry.handler('new_agent_task')
def handle_new_agent_task(request: IPCRequest, params: Optional[Dict[str, Any]]) -> IPCResponse:
    """Handle creating new agent task and saving to local database

    Args:
        request: IPC request object
        params: Request parameters, must contain 'username' and 'task_info' fields

    Returns:
        JSON formatted response message
    """
    try:
        logger.debug(f"Create new task handler called with request: {request}")

        # Validate parameters
        is_valid, data, error = validate_params(params, ['username', 'task_info'])
        if not is_valid:
            logger.warning(f"Invalid parameters for create task: {error}")
            return create_error_response(request, 'INVALID_PARAMS', error)

        username = data['username']
        agent_task_info = data['task_info']

        logger.info(f"Creating new agent task for user: {username}")

        # Get database service
        agent_task_service = _get_agent_task_service()
        if not agent_task_service:
            return create_error_response(request, 'SERVICE_ERROR', 'Database service not available')

        # Prepare agent task data (without ID - let database generate it)
        agent_task_data = _prepare_agent_task_data(agent_task_info, username, agent_task_id=None)

        # Create new agent task in database
        logger.info(f"Creating new agent task: {agent_task_data['name']}")
        result = agent_task_service.add_task(agent_task_data)

        if result.get('success'):
            # Get the database-generated agent task ID
            agent_task_id = result.get('id')
            if not agent_task_id:
                logger.error("Database did not return agent task ID after creation")
                return create_error_response(
                    request,
                    'CREATE_TASK_ERROR',
                    'Database did not return agent task ID'
                )

            logger.info(f"Agent task created successfully: {agent_task_data['name']} (ID: {agent_task_id})")

            # Step 2: Update memory after database creation succeeds
            _update_agent_task_in_memory(agent_task_id, agent_task_data)

            # Step 3: Sync to cloud after memory update succeeds (async, fire and forget)
            task_data_with_id = agent_task_data.copy()
            task_data_with_id['id'] = agent_task_id
            
            # Sync Task entity
            _trigger_cloud_sync(task_data_with_id, Operation.ADD)
            
            # Sync Task-Skill relationships
            if 'skills' in agent_task_data:
                _sync_task_skill_relations(agent_task_id, agent_task_data.get('skills', []), Operation.ADD)

            # Create clean response
            clean_agent_task_data = _create_clean_agent_task_response(agent_task_id, agent_task_data)

            return create_success_response(request, {
                'message': 'Create agent task successful',
                'task_id': agent_task_id,
                'data': clean_agent_task_data
            })
        else:
            logger.error(f"Failed to create agent task: {result.get('error')}")
            return create_error_response(
                request,
                'CREATE_TASK_ERROR',
                f"Failed to create agent task: {result.get('error')}"
            )

    except Exception as e:
        logger.error(f"Error in create task handler: {e} {traceback.format_exc()}")
        return create_error_response(
            request,
            'CREATE_TASK_ERROR',
            f"Error during create task: {str(e)}"
        )


@IPCHandlerRegistry.handler('delete_agent_task')
def handle_delete_agent_task(request: IPCRequest, params: Optional[Dict[str, Any]]) -> IPCResponse:
    """Handle deleting agent task from database and memory

    Args:
        request: IPC request object
        params: Request parameters, must contain 'username' and 'task_id' fields

    Returns:
        JSON formatted response message
    """
    try:
        logger.debug(f"Delete task handler called with request: {request}")

        # Validate parameters
        is_valid, data, error = validate_params(params, ['username', 'task_id'])
        if not is_valid:
            logger.warning(f"Invalid parameters for delete task: {error}")
            return create_error_response(request, 'INVALID_PARAMS', error)

        username = data['username']
        agent_task_id = data['task_id']

        logger.info(f"Deleting agent task for user: {username}, agent_task_id: {agent_task_id}")

        # Get database service
        agent_task_service = _get_agent_task_service()
        if not agent_task_service:
            return create_error_response(request, 'SERVICE_ERROR', 'Database service not available')

        # Step 1: Delete from database first
        result = agent_task_service.delete_task(agent_task_id)

        if result.get('success'):
            logger.info(f"Agent task deleted successfully from database: {agent_task_id}")

            # Step 2: Remove from memory after database deletion succeeds
            try:
                main_window = AppContext.get_main_window()
                if main_window and hasattr(main_window, 'agent_tasks'):
                    original_count = len(main_window.agent_tasks or [])
                    main_window.agent_tasks = [
                        agent_task for agent_task in (main_window.agent_tasks or [])
                        if not (hasattr(agent_task, 'id') and agent_task.id == agent_task_id)
                    ]
                    new_count = len(main_window.agent_tasks)
                    logger.info(f"[task_handler] Removed agent task from memory: {agent_task_id} (count: {original_count} ‚Üí {new_count})")
            except Exception as e:
                logger.warning(f"[task_handler] Failed to remove agent task from memory: {e}")

            # Step 3: Clean up offline sync queue for this task
            try:
                from agent.cloud_api.offline_sync_queue import get_offline_sync_queue
                sync_queue = get_offline_sync_queue()
                removed_count = sync_queue.remove_tasks_by_resource('task', agent_task_id)
                if removed_count > 0:
                    logger.info(f"[task_handler] Removed {removed_count} pending sync tasks for task: {agent_task_id}")
            except Exception as e:
                logger.warning(f"[task_handler] Failed to clean offline sync queue: {e}")

            # Step 4: Sync deletion to cloud after memory update (async, fire and forget)
            delete_task_data = {
                'id': agent_task_id,
                'owner': username,
                'name': f"Task_{agent_task_id}"  # Placeholder name for deletion
            }
            _trigger_cloud_sync(delete_task_data, Operation.DELETE)

            return create_success_response(request, {
                'message': 'Delete agent task successful',
                'task_id': agent_task_id
            })
        else:
            logger.error(f"Failed to delete agent task: {result.get('error')}")
            return create_error_response(
                request,
                'DELETE_TASK_ERROR',
                f"Failed to delete agent task: {result.get('error')}"
            )

    except Exception as e:
        logger.error(f"Error in delete task handler: {e} {traceback.format_exc()}")
        return create_error_response(
            request,
            'DELETE_TASK_ERROR',
            f"Error during delete task: {str(e)}"
        )


# ============================================================================
# Cloud Synchronization Functions
# ============================================================================


def _trigger_cloud_sync(task_data: Dict[str, Any], operation: 'Operation') -> None:
    """Trigger cloud synchronization (async, non-blocking)
    
    Async background execution, doesn't block UI operations, ensures eventual consistency.
    
    Args:
        task_data: Task data to sync
        operation: Operation type (Operation enum)
    """
    from agent.cloud_api.offline_sync_manager import get_sync_manager
    from agent.cloud_api.constants import DataType
    
    def _log_result(result: Dict[str, Any]):
        """Log sync result"""
        if result.get('synced'):
            logger.info(f"[task_handler] ‚úÖ Task synced to cloud: {operation} - {task_data.get('name')}")
        elif result.get('cached'):
            logger.info(f"[task_handler] üíæ Task cached for later sync: {operation} - {task_data.get('name')}")
        elif not result.get('success'):
            logger.error(f"[task_handler] ‚ùå Failed to sync task: {result.get('error')}")
    
    # Use SyncManager's thread pool for async execution
    # Note: Use TASK for Task entity data (name, description, etc.)
    #       Use AGENT_TASK for Agent-Task relationship data (agid, task_id, owner)
    manager = get_sync_manager()
    manager.sync_to_cloud_async(DataType.TASK, task_data, operation, callback=_log_result)


def _sync_task_skill_relations(task_id: str, skill_ids: list, operation: 'Operation') -> None:
    """Sync Task-Skill relationships to cloud (async, non-blocking)
    
    Args:
        task_id: Task ID
        skill_ids: List of skill IDs
        operation: Operation type (ADD/UPDATE/DELETE)
    """
    if not skill_ids:
        return
    
    from agent.cloud_api.offline_sync_manager import get_sync_manager
    from agent.cloud_api.constants import DataType
    from app_context import AppContext
    
    manager = get_sync_manager()
    main_window = AppContext.get_main_window()
    owner = main_window.current_user if main_window else 'unknown'
    
    logger.info(f"[task_handler] Syncing {len(skill_ids)} skill relationships for task: {task_id}")
    
    for skill_id in skill_ids:
        relation_data = {
            'task_id': task_id,
            'skill_id': skill_id,
            'owner': owner
        }
        
        def _log_result(result: Dict[str, Any]):
            if result.get('synced'):
                logger.info(f"[task_handler] ‚úÖ Skill relation synced: {skill_id}")
            elif result.get('cached'):
                logger.info(f"[task_handler] üíæ Skill relation cached: {skill_id}")
            elif not result.get('success'):
                logger.error(f"[task_handler] ‚ùå Failed to sync skill relation: {result.get('error')}")
        
        manager.sync_to_cloud_async(DataType.TASK_SKILL, relation_data, operation, callback=_log_result)