import traceback
from typing import TYPE_CHECKING, Any, Optional, Dict
from app_context import AppContext
if TYPE_CHECKING:
    from gui.MainGUI import MainWindow
from gui.ipc.handlers import validate_params
from gui.ipc.registry import IPCHandlerRegistry
from gui.ipc.types import IPCRequest, IPCResponse, create_error_response, create_success_response
from agent.cloud_api.constants import Operation

from utils.logger_helper import logger_helper as logger


# ============================================================================
# Helper Functions for Agent Task Management
# ============================================================================

def _serialize_task_status(status) -> str:
    """Serialize TaskStatus object to a JSON-serializable string
    
    Args:
        status: TaskStatus object, string, or None
        
    Returns:
        str: Status string (e.g., 'pending', 'working', 'completed')
    """
    if status is None:
        return 'pending'
    
    # If it's already a string, return it
    if isinstance(status, str):
        return status
    
    # If it's a TaskStatus object (Pydantic model), extract the state
    if hasattr(status, 'state'):
        state = status.state
        # TaskState is an enum, get its value
        if hasattr(state, 'value'):
            return state.value
        return str(state)
    
    # Fallback: convert to string
    return str(status)


def _get_agent_task_service():
    """Get agent task service from mainwin (uses correct user-specific database path)

    Returns:
        task_service: Database agent task service instance, or None if not available
    """
    main_window = AppContext.get_ctx()
    if ctx:
        return ctx.get_ec_db_mgr().task_service
    else:
        logger.error("[task_handler] mainwin.ec_db_mgr not available - cannot access database")
        return None


def _prepare_agent_task_data(agent_task_info: Dict[str, Any], username: str, agent_task_id: Optional[str] = None) -> Dict[str, Any]:
    """Prepare agent task data for database storage

    Args:
        agent_task_info: Raw agent task information from frontend
        username: Owner username
        agent_task_id: Optional agent task ID (if None, will be generated by database)

    Returns:
        Dict containing prepared agent task data
    """
    # Get metadata from frontend (could be 'metadata' or 'settings' key)
    metadata = agent_task_info.get('metadata', agent_task_info.get('settings', {}))
    if not isinstance(metadata, dict):
        metadata = {}
    
    # NOTE: skill is now managed through task-skill relationship table (DBAgentTaskSkillRel)
    # Don't store skill in metadata anymore
    
    agent_task_data = {
        'name': agent_task_info.get('name', 'Unnamed Agent Task'),
        'owner': username,
        'description': agent_task_info.get('description', ''),
        'source': agent_task_info.get('source', 'ui'),
        'priority': agent_task_info.get('priority', 'medium'),
        'status': agent_task_info.get('status', 'pending'),
        'task_type': agent_task_info.get('task_type', ''),
        'objectives': agent_task_info.get('objectives', []),
        'schedule': agent_task_info.get('schedule', {}),
        'trigger': agent_task_info.get('trigger', 'manual'),
        'progress': agent_task_info.get('progress', 0.0),
        'result': agent_task_info.get('result', {}),
        'error_message': agent_task_info.get('error_message', ''),
        'settings': metadata,
        'org_id': agent_task_info.get('org_id', None),
    }

    # Only add ID if provided (for updates)
    if agent_task_id:
        agent_task_data['id'] = agent_task_id

    return agent_task_data


def _manage_task_skill_relationship(task_id: str, skill_id: Optional[str]) -> bool:
    """Create or update task-skill relationship using task service
    
    Args:
        task_id: Task ID
        skill_id: Skill ID (None to remove relationship)
        
    Returns:
        bool: True if successful
    """
    try:
        task_service = _get_agent_task_service()
        if not task_service:
            return False
        
        # Get existing skills for this task
        existing_skills = task_service.get_task_skills(task_id, role='primary')
        
        # Remove existing primary skill relationships
        if existing_skills.get('success') and existing_skills.get('data'):
            for skill_rel in existing_skills['data']:
                task_service.remove_skill_from_task(task_id, skill_rel['skill_id'])
        
        # Add new relationship if skill_id provided
        if skill_id:
            result = task_service.add_skill_to_task(
                task_id=task_id,
                skill_id=skill_id,
                role='primary',
                is_required=True
            )
            if not result.get('success'):
                logger.error(f"[task_handler] Failed to add skill to task: {result.get('error')}")
                return False
        
        return True
            
    except Exception as e:
        logger.error(f"[task_handler] Failed to manage task-skill relationship: {e}")
        return False


def _get_task_skill_info(task_id: str) -> Optional[Dict[str, Any]]:
    """Get skill information from task-skill relationship using task service
    
    Args:
        task_id: Task ID
        
    Returns:
        Dict with skill info (id, name) or None
    """
    try:
        task_service = _get_agent_task_service()
        if not task_service:
            logger.error(f"[task_handler] Task service not available")
            return None
        
        skills = task_service.get_task_skills(task_id, role='primary')
        
        if skills.get('success') and skills.get('data'):
            skill_rels = skills['data']
            if skill_rels and len(skill_rels) > 0:
                skill_rel = skill_rels[0]
                skill_id = skill_rel.get('skill_id')
                
                if skill_id:
                    main_window = AppContext.get_ctx()
                    
                    if ctx:
                        skill_service = ctx.get_ec_db_mgr().get_skill_service()
                        
                        if skill_service:
                            skill_result = skill_service.get_skill_by_id(skill_id)
                            if skill_result.get('success') and skill_result.get('data'):
                                skill_data = skill_result['data']
                                return {
                                    'id': skill_data.get('id'),
                                    'name': skill_data.get('name')
                                }
        
        return None
        
    except Exception as e:
        logger.error(f"[task_handler] Failed to get task skill info: {e}")
        return None


def _update_agent_task_in_memory(agent_task_id: str, agent_task_data: Dict[str, Any]) -> bool:
    """Update or add agent task in mainwin.agent_tasks memory

    Args:
        agent_task_id: Agent task ID
        agent_task_data: Agent task data dictionary

    Returns:
        bool: True if successful, False otherwise
    """
    try:
        main_window = AppContext.get_ctx()
        if not ctx or not hasattr(ctx, 'agent_tasks'):
            logger.warning("[task_handler] mainwin.agent_tasks not available")
            return False

        from agent.ec_tasks import ManagedTask
        from agent.a2a.common.types import TaskStatus, TaskState

        # Check if agent task already exists in memory
        existing_index = None
        for i, agent_task in enumerate(ctx.get_agent_tasks() or []):
            if hasattr(agent_task, 'id') and agent_task.id == agent_task_id:
                existing_index = i
                break

        # Create agent task object with all required fields
        # ManagedTask requires: id, name, status (with state), skill, state
        # Valid TaskState values: submitted, working, input-required, completed, canceled, failed, unknown
        task_status = agent_task_data.get('status', 'submitted')
        # Map common status values to valid TaskState
        status_mapping = {
            'pending': 'submitted',
            'ready': 'submitted',
            'running': 'working',
            'paused': 'input-required',
            'done': 'completed',
            'error': 'failed'
        }
        task_status = status_mapping.get(task_status, task_status)
        
        # Get metadata from 'settings' (DB field name) or 'metadata' (API field name)
        metadata = agent_task_data.get('settings', agent_task_data.get('metadata', {}))
        if not isinstance(metadata, dict):
            metadata = {}
        
        # Get skill from task-skill relationship table
        skill_info = _get_task_skill_info(agent_task_id)
        skill_name = skill_info['name'] if skill_info else ''
        
        agent_task_obj = ManagedTask(
            id=agent_task_id,
            name=agent_task_data['name'],
            description=agent_task_data.get('description', ''),
            owner=agent_task_data['owner'],
            status=TaskStatus(
                state=TaskState(task_status)
            ),
            skill=skill_name,
            state={},
            metadata=metadata
        )

        if existing_index is not None:
            # Update existing agent task
            agent_tasks = ctx.get_agent_tasks()
            if agent_tasks is not None:
                agent_tasks[existing_index] = agent_task_obj
            logger.info(f"[task_handler] Updated agent task in memory: {agent_task_data['name']}")
        else:
            # Add new agent task
            agent_tasks = ctx.get_agent_tasks()
            if agent_tasks is not None:
                agent_tasks.append(agent_task_obj)
                logger.info(f"[task_handler] Added new agent task to memory: {agent_task_data['name']}")

        return True

    except Exception as e:
        logger.warning(f"[task_handler] Failed to update mainwin.agent_tasks: {e}")
        return False


def _create_clean_agent_task_response(agent_task_id: str, agent_task_data: Dict[str, Any]) -> Dict[str, Any]:
    """Create clean agent task data for response (avoid circular references)

    Args:
        agent_task_id: Agent task ID
        agent_task_data: Agent task data dictionary

    Returns:
        Dict containing clean agent task data
    """
    # Get metadata from 'settings' (DB field name) or 'metadata' (API field name)
    metadata = agent_task_data.get('settings', agent_task_data.get('metadata', {}))
    if not isinstance(metadata, dict):
        metadata = {}
    
    # Get skill info from task-skill relationship table
    skill_info = _get_task_skill_info(agent_task_id)
    skill_name = skill_info['name'] if skill_info else ''
    
    return {
        'id': agent_task_id,
        'name': agent_task_data['name'],
        'owner': agent_task_data['owner'],
        'description': agent_task_data['description'],
        'priority': agent_task_data.get('priority', 'medium'),
        'status': agent_task_data.get('status', 'pending'),
        'task_type': agent_task_data.get('task_type', ''),
        'progress': agent_task_data.get('progress', 0.0),
        'schedule': agent_task_data.get('schedule', {}),
        'trigger': agent_task_data.get('trigger', 'manual'),
        'skill': skill_name,  # Get skill from relationship table
        'metadata': metadata
    }

@IPCHandlerRegistry.handler('get_agent_tasks')
def handle_get_agent_tasks(request: IPCRequest, params: Optional[Dict[str, Any]]) -> IPCResponse:
    """Get agent tasks list from database

    Reads agent tasks from database to ensure all fields (including 'source') are available.
    Falls back to memory if database is not available.

    Args:
        request: IPC request object
        params: Request parameters, must contain 'username' field

    Returns:
        JSON formatted response message
    """
    try:
        logger.debug(f"Get agent tasks handler called with request: {request}")

        # Validate parameters
        is_valid, data, error = validate_params(params, ['username'])
        if not is_valid:
            logger.warning(f"Invalid parameters for get agent tasks: {error}")
            return create_error_response(
                request,
                'INVALID_PARAMS',
                error
            )

        username = data['username']
        logger.info(f"Getting agent tasks for user: {username}")

        # Get tasks from memory (mainwin.agent_tasks is the single source of truth)
        # Tasks are loaded from database during startup
        try:
            main_window = AppContext.get_ctx()
            memory_agent_tasks = ctx.get_agent_tasks() or []
            logger.info(f"Found {len(memory_agent_tasks)} agent tasks in memory (mainwin.agent_tasks)")

            # Convert tasks to dictionary format
            agent_tasks_dicts = []
            for i, agent_task in enumerate(memory_agent_tasks):
                try:
                    # Use Pydantic's model_dump() for proper serialization
                    if hasattr(agent_task, 'model_dump'):
                        # Pydantic v2: model_dump() with exclude for non-serializable fields
                        # Exclude 'skill' since it can be complex object (StateGraph)
                        agent_task_dict = agent_task.model_dump(
                            exclude={'skill', 'task', 'pause_event', 'cancellation_event', 'queue'},
                            mode='json'
                        )
                    elif hasattr(agent_task, 'dict'):
                        # Pydantic v1: dict() method
                        # Exclude 'skill' since it can be complex object (StateGraph)
                        agent_task_dict = agent_task.dict(
                            exclude={'skill', 'task', 'pause_event', 'cancellation_event', 'queue'}
                        )
                    else:
                        # ‚ùå Error: agent_task should be a Pydantic model
                        logger.error(f"Agent task {i} is not a Pydantic model! Type: {type(agent_task)}, Name: {getattr(agent_task, 'name', 'UNKNOWN')}")
                        logger.error(f"This indicates a serious data structure issue. Skipping this task.")
                        continue
                    
                    # Manually extract skill name (handle both string and object)
                    skill_value = getattr(agent_task, 'skill', None)
                    
                    if isinstance(skill_value, str):
                        agent_task_dict['skill'] = skill_value
                    elif skill_value and hasattr(skill_value, 'name'):
                        agent_task_dict['skill'] = skill_value.name
                    else:
                        agent_task_dict['skill'] = ''
                    
                    # Ensure owner field is set
                    agent_task_dict['owner'] = username
                    if 'id' not in agent_task_dict:
                        agent_task_dict['id'] = f"agent_task_{i}"
                    
                    # Serialize status properly
                    if 'status' in agent_task_dict:
                        agent_task_dict['status'] = _serialize_task_status(agent_task_dict['status'])
                    
                    agent_tasks_dicts.append(agent_task_dict)
                    logger.debug(f"Converted agent task: {agent_task_dict.get('name', 'NO NAME')}, source: {agent_task_dict.get('source', 'N/A')}, metadata: {agent_task_dict.get('metadata', 'N/A')}")
                except Exception as e:
                    logger.error(f"Failed to convert agent task {i}: {e}")
                    import traceback
                    logger.error(f"Traceback: {traceback.format_exc()}")
                    # Skip this task instead of crashing the entire request
                    continue

            logger.info(f"Returning {len(agent_tasks_dicts)} agent tasks to frontend")

            resultJS = {
                'tasks': agent_tasks_dicts,
                'message': 'Get agent tasks successful',
            }
            return create_success_response(request, resultJS)

        except Exception as e:
            logger.error(f"Failed to get agent tasks from memory: {e}")
            # Return empty list as fallback
            return create_success_response(request, {
                'tasks': [],
                'message': 'No agent tasks available',
            })

    except Exception as e:
        logger.error(f"Error in get agent tasks handler: {e} {traceback.format_exc()}")
        return create_error_response(
            request,
            'GET_TASKS_ERROR',
            f"Error during get agent tasks: {str(e)}"
        )
    
@IPCHandlerRegistry.handler('save_agent_task')
def handle_save_agent_task(request: IPCRequest, params: Optional[Dict[str, Any]]) -> IPCResponse:
    """Handle saving agent task to local database

    Args:
        request: IPC request object
        params: Request parameters, must contain 'username' and 'task_info' fields

    Returns:
        JSON formatted response message
    """
    try:
        logger.debug(f"Save task handler called with request: {request}")

        # Validate parameters
        is_valid, data, error = validate_params(params, ['username', 'task_info'])
        if not is_valid:
            logger.warning(f"Invalid parameters for save task: {error}")
            return create_error_response(request, 'INVALID_PARAMS', error)

        username = data['username']
        agent_task_info = data['task_info']
        agent_task_id = agent_task_info.get('id')
        

        if not agent_task_id:
            return create_error_response(request, 'INVALID_PARAMS', 'Agent task ID is required for save operation')

        # ‚ö†Ô∏è Prevent saving code-generated tasks to database
        task_source = agent_task_info.get('source', 'ui')
        if task_source == 'code':
            logger.warning(f"Blocked attempt to save code-generated task '{agent_task_info.get('name')}' to database")
            return create_error_response(
                request, 
                'INVALID_OPERATION', 
                'Cannot save code-generated tasks to database. Code-generated tasks are read-only.'
            )

        logger.info(f"Saving agent task for user: {username}, agent_task_id: {agent_task_id}")

        # Get database service
        agent_task_service = _get_agent_task_service()
        if not agent_task_service:
            return create_error_response(request, 'SERVICE_ERROR', 'Database service not available')

        # Prepare agent task data
        agent_task_data = _prepare_agent_task_data(agent_task_info, username, agent_task_id)

        # Check if agent task exists
        existing_agent_task = agent_task_service.query_tasks(id=agent_task_id)

        if existing_agent_task.get('success') and existing_agent_task.get('data'):
            # Update existing agent task
            existing_data = existing_agent_task.get('data', [{}])[0] if existing_agent_task.get('data') else {}
            logger.info(f"[task_handler] Existing task metadata before update: {existing_data.get('metadata', existing_data.get('settings', {}))}")
            logger.info(f"Updating existing agent task: {agent_task_id}")
            result = agent_task_service.update_task(agent_task_id, agent_task_data)
            logger.info(f"[task_handler] Update result: {result}")
        else:
            # Create new agent task
            logger.info(f"Creating new agent task: {agent_task_id}")
            result = agent_task_service.add_task(agent_task_data)

        if result.get('success'):
            # Get the actual agent_task_id from database response (in case it was generated)
            actual_agent_task_id = result.get('id', agent_task_id)
            logger.info(f"Agent task saved successfully: {agent_task_data['name']} (ID: {actual_agent_task_id})")

            # Step 1.5: Manage task-skill relationship
            skill_id = agent_task_info.get('skill_id')
            if skill_id or skill_id is None:  # Update relationship (including removing)
                _manage_task_skill_relationship(actual_agent_task_id, skill_id)

            # Step 2: Update memory after database update succeeds
            _update_agent_task_in_memory(actual_agent_task_id, agent_task_data)

            # Step 3: Clean up offline sync queue for this task (remove pending add/update operations)
            try:
                from agent.cloud_api.offline_sync_queue import get_offline_sync_queue
                sync_queue = get_offline_sync_queue()
                # Remove any pending add operations (they're now redundant since we're updating)
                removed_add = sync_queue.remove_tasks_by_resource('task', actual_agent_task_id, operation='add')
                # Remove any pending update operations (they're now redundant since we have a new update)
                removed_update = sync_queue.remove_tasks_by_resource('task', actual_agent_task_id, operation='update')
                if removed_add + removed_update > 0:
                    logger.info(f"[task_handler] Removed {removed_add + removed_update} pending sync tasks for task: {actual_agent_task_id}")
            except Exception as e:
                logger.warning(f"[task_handler] Failed to clean offline sync queue: {e}")

            # Step 4: Sync to cloud after memory update succeeds (async, fire and forget)
            task_data_with_id = agent_task_data.copy()
            task_data_with_id['id'] = actual_agent_task_id
            
            # Sync Task entity
            _trigger_cloud_sync(task_data_with_id, Operation.UPDATE)
            
            # Sync Task-Skill relationships (if changed)
            if 'skills' in agent_task_data:
                _sync_task_skill_relations(actual_agent_task_id, agent_task_data.get('skills', []), Operation.UPDATE)

            # Create clean response
            clean_agent_task_data = _create_clean_agent_task_response(actual_agent_task_id, agent_task_data)

            return create_success_response(request, {
                'message': 'Save agent task successful',
                'task_id': actual_agent_task_id,
                'data': clean_agent_task_data
            })
        else:
            logger.error(f"Failed to save agent task: {result.get('error')}")
            return create_error_response(
                request,
                'SAVE_TASK_ERROR',
                f"Failed to save agent task: {result.get('error')}"
            )

    except Exception as e:
        logger.error(f"Error in save task handler: {e} {traceback.format_exc()}")
        return create_error_response(
            request,
            'SAVE_TASK_ERROR',
            f"Error during save task: {str(e)}"
        )


@IPCHandlerRegistry.handler('new_agent_task')
def handle_new_agent_task(request: IPCRequest, params: Optional[Dict[str, Any]]) -> IPCResponse:
    """Handle creating new agent task and saving to local database

    Args:
        request: IPC request object
        params: Request parameters, must contain 'username' and 'task_info' fields

    Returns:
        JSON formatted response message
    """
    try:
        logger.debug(f"Create new task handler called with request: {request}")

        # Validate parameters
        is_valid, data, error = validate_params(params, ['username', 'task_info'])
        if not is_valid:
            logger.warning(f"Invalid parameters for create task: {error}")
            return create_error_response(request, 'INVALID_PARAMS', error)

        username = data['username']
        agent_task_info = data['task_info']

        logger.info(f"Creating new agent task for user: {username}")

        # Get database service
        agent_task_service = _get_agent_task_service()
        if not agent_task_service:
            return create_error_response(request, 'SERVICE_ERROR', 'Database service not available')

        # Prepare agent task data (without ID - let database generate it)
        agent_task_data = _prepare_agent_task_data(agent_task_info, username, agent_task_id=None)

        # Create new agent task in database
        logger.info(f"Creating new agent task: {agent_task_data['name']}")
        result = agent_task_service.add_task(agent_task_data)

        if result.get('success'):
            # Get the database-generated agent task ID
            agent_task_id = result.get('id')
            if not agent_task_id:
                logger.error("Database did not return agent task ID after creation")
                return create_error_response(
                    request,
                    'CREATE_TASK_ERROR',
                    'Database did not return agent task ID'
                )

            logger.info(f"Agent task created successfully: {agent_task_data['name']} (ID: {agent_task_id})")

            # Step 2: Update memory after database creation succeeds
            _update_agent_task_in_memory(agent_task_id, agent_task_data)

            # Step 3: Sync to cloud after memory update succeeds (async, fire and forget)
            task_data_with_id = agent_task_data.copy()
            task_data_with_id['id'] = agent_task_id
            
            # Sync Task entity
            _trigger_cloud_sync(task_data_with_id, Operation.ADD)
            
            # Sync Task-Skill relationships
            if 'skills' in agent_task_data:
                _sync_task_skill_relations(agent_task_id, agent_task_data.get('skills', []), Operation.ADD)

            # Create clean response
            clean_agent_task_data = _create_clean_agent_task_response(agent_task_id, agent_task_data)

            return create_success_response(request, {
                'message': 'Create agent task successful',
                'task_id': agent_task_id,
                'data': clean_agent_task_data
            })
        else:
            logger.error(f"Failed to create agent task: {result.get('error')}")
            return create_error_response(
                request,
                'CREATE_TASK_ERROR',
                f"Failed to create agent task: {result.get('error')}"
            )

    except Exception as e:
        logger.error(f"Error in create task handler: {e} {traceback.format_exc()}")
        return create_error_response(
            request,
            'CREATE_TASK_ERROR',
            f"Error during create task: {str(e)}"
        )


@IPCHandlerRegistry.handler('delete_agent_task')
def handle_delete_agent_task(request: IPCRequest, params: Optional[Dict[str, Any]]) -> IPCResponse:
    """Handle deleting agent task from database and memory

    Args:
        request: IPC request object
        params: Request parameters, must contain 'username' and 'task_id' fields

    Returns:
        JSON formatted response message
    """
    try:
        logger.debug(f"Delete task handler called with request: {request}")

        # Validate parameters
        is_valid, data, error = validate_params(params, ['username', 'task_id'])
        if not is_valid:
            logger.warning(f"Invalid parameters for delete task: {error}")
            return create_error_response(request, 'INVALID_PARAMS', error)

        username = data['username']
        agent_task_id = data['task_id']

        # ‚ö†Ô∏è Prevent deleting code-generated tasks from database
        # First check if this is a code-generated task by checking memory
        main_window = AppContext.get_ctx()
        if ctx:
            existing_task = next((t for t in ctx.get_agent_tasks() if getattr(t, 'id', None) == agent_task_id), None)
            if existing_task and getattr(existing_task, 'source', 'ui') == 'code':
                logger.warning(f"Blocked attempt to delete code-generated task '{getattr(existing_task, 'name', 'Unknown')}' from database")
                return create_error_response(
                    request,
                    'INVALID_OPERATION',
                    'Cannot delete code-generated tasks. Code-generated tasks are read-only.'
                )

        logger.info(f"Deleting agent task for user: {username}, agent_task_id: {agent_task_id}")

        # Get database service
        agent_task_service = _get_agent_task_service()
        if not agent_task_service:
            return create_error_response(request, 'SERVICE_ERROR', 'Database service not available')

        # Step 1: Delete from database first
        result = agent_task_service.delete_task(agent_task_id)

        if result.get('success'):
            logger.info(f"Agent task deleted successfully from database: {agent_task_id}")

            # Step 2: Remove from memory after database deletion succeeds
            try:
                agent_tasks = ctx.get_agent_tasks()
                if agent_tasks is not None:
                    original_count = len(agent_tasks)
                    agent_tasks[:] = [
                        agent_task for agent_task in agent_tasks
                        if not (hasattr(agent_task, 'id') and agent_task.id == agent_task_id)
                    ]
                    new_count = len(agent_tasks)
                    logger.info(f"[task_handler] Removed agent task from memory: {agent_task_id} (count: {original_count} ‚Üí {new_count})")
            except Exception as e:
                logger.warning(f"[task_handler] Failed to remove agent task from memory: {e}")

            # Step 3: Clean up offline sync queue for this task
            try:
                from agent.cloud_api.offline_sync_queue import get_offline_sync_queue
                sync_queue = get_offline_sync_queue()
                removed_count = sync_queue.remove_tasks_by_resource('task', agent_task_id)
                if removed_count > 0:
                    logger.info(f"[task_handler] Removed {removed_count} pending sync tasks for task: {agent_task_id}")
            except Exception as e:
                logger.warning(f"[task_handler] Failed to clean offline sync queue: {e}")

            # Step 4: Sync deletion to cloud after memory update (async, fire and forget)
            delete_task_data = {
                'id': agent_task_id,
                'owner': username,
                'name': f"Task_{agent_task_id}"  # Placeholder name for deletion
            }
            _trigger_cloud_sync(delete_task_data, Operation.DELETE)

            return create_success_response(request, {
                'message': 'Delete agent task successful',
                'task_id': agent_task_id
            })
        else:
            logger.error(f"Failed to delete agent task: {result.get('error')}")
            return create_error_response(
                request,
                'DELETE_TASK_ERROR',
                f"Failed to delete agent task: {result.get('error')}"
            )

    except Exception as e:
        logger.error(f"Error in delete task handler: {e} {traceback.format_exc()}")
        return create_error_response(
            request,
            'DELETE_TASK_ERROR',
            f"Error during delete task: {str(e)}"
        )


# ============================================================================
# Cloud Synchronization Functions
# ============================================================================


def _trigger_cloud_sync(task_data: Dict[str, Any], operation: 'Operation') -> None:
    """Trigger cloud synchronization (async, non-blocking)
    
    Async background execution, doesn't block UI operations, ensures eventual consistency.
    
    Args:
        task_data: Task data to sync
        operation: Operation type (Operation enum)
    """
    from agent.cloud_api.offline_sync_manager import get_sync_manager
    from agent.cloud_api.constants import DataType
    
    def _log_result(result: Dict[str, Any]):
        """Log sync result"""
        if result.get('synced'):
            logger.info(f"[task_handler] ‚úÖ Task synced to cloud: {operation} - {task_data.get('name')}")
        elif result.get('cached'):
            logger.info(f"[task_handler] üíæ Task cached for later sync: {operation} - {task_data.get('name')}")
        elif not result.get('success'):
            logger.error(f"[task_handler] ‚ùå Failed to sync task: {result.get('error')}")
    
    # Use SyncManager's thread pool for async execution
    # Note: Use TASK for Task entity data (name, description, etc.)
    #       Use AGENT_TASK for Agent-Task relationship data (agid, task_id, owner)
    manager = get_sync_manager()
    manager.sync_to_cloud_async(DataType.TASK, task_data, operation, callback=_log_result)


def _sync_task_skill_relations(task_id: str, skill_ids: list, operation: 'Operation') -> None:
    """Sync Task-Skill relationships to cloud (async, non-blocking)
    
    Args:
        task_id: Task ID
        skill_ids: List of skill IDs
        operation: Operation type (ADD/UPDATE/DELETE)
    """
    if not skill_ids:
        return
    
    from agent.cloud_api.offline_sync_manager import get_sync_manager
    from agent.cloud_api.constants import DataType
    from app_context import AppContext
    
    manager = get_sync_manager()
    main_window = AppContext.get_ctx()
    owner = ctx.get_username() if ctx else 'unknown'
    
    logger.info(f"[task_handler] Syncing {len(skill_ids)} skill relationships for task: {task_id}")
    
    for skill_id in skill_ids:
        relation_data = {
            'task_id': task_id,
            'skill_id': skill_id,
            'owner': owner
        }
        
        def _log_result(result: Dict[str, Any]):
            if result.get('synced'):
                logger.info(f"[task_handler] ‚úÖ Skill relation synced: {skill_id}")
            elif result.get('cached'):
                logger.info(f"[task_handler] üíæ Skill relation cached: {skill_id}")
            elif not result.get('success'):
                logger.error(f"[task_handler] ‚ùå Failed to sync skill relation: {result.get('error')}")
        
        manager.sync_to_cloud_async(DataType.TASK_SKILL, relation_data, operation, callback=_log_result)