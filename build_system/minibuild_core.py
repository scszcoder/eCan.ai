#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Minibuild core: a simplified, maintainable build pipeline for PyInstaller.

Design goals:
- Single spec generator with minimal dynamic-import detection
- Minimal config surface (reuse build_system/build_config.json where possible)
- Default to onedir; onefile optional per mode
- Works on Windows and macOS; supports macOS .app (BUNDLE) and PKG via existing InstallerBuilder
- Very small hook surface (reuse existing build_system/pyinstaller_hooks)
"""
from __future__ import annotations

import ast
import json
import sys
import subprocess
import os
from pathlib import Path
from typing import Dict, List, Set, Any, Optional
import shutil

# Import platform handler
try:
    from .platform_handler import platform_handler
except ImportError:
    # Handle case when imported directly
    from platform_handler import platform_handler


class MiniSpecBuilder:
    def __init__(self, project_root: Optional[Path] = None, config_path: str = "build_system/build_config.json"):
        self.project_root = project_root or Path.cwd()
        self.config_path = self.project_root / config_path
        with open(self.config_path, "r", encoding="utf-8") as f:
            self.cfg: Dict[str, Any] = json.load(f)
        # Generated hooks directory (for pre_safe_import_module)
        self.gen_hooks_dir = self.project_root / "build" / "pyinstaller_hooks_gen"
        self.pre_safe_dir = self.gen_hooks_dir / "pre_safe_import_module"

    # ---- Public API ----
    def build(self, mode: str = "fast") -> bool:
        # Generate essential pre-safe hooks for known problematic modules
        self._ensure_pre_safe_hooks()
        self._ensure_global_sitecustomize()

        # Write spec file
        self._last_spec_path = self._write_spec(mode)
        
        # Run PyInstaller
        # Use virtual environment Python if available, fallback to sys.executable
        python_executable = self._get_python_executable()
        cmd = [python_executable, "-m", "PyInstaller", str(self._last_spec_path), "--noconfirm", "--clean"]
        print(f"[MINIBUILD] Running: {' '.join(cmd)}")
        env = os.environ.copy()
        py_path = str(self.gen_hooks_dir)
        env["PYTHONPATH"] = (py_path + (os.pathsep + env.get("PYTHONPATH", "") if env.get("PYTHONPATH") else ""))
        env["PYTHONUTF8"] = "1"
        
        result = subprocess.run(cmd, cwd=str(self.project_root), env=env)
        if result.returncode != 0:
            print(f"[MINIBUILD] Build failed with code {result.returncode}")
            return False
        print("[MINIBUILD] Build succeeded")
        return True

    def _ensure_pre_safe_hooks(self) -> None:
        """Generate essential pre-safe hooks for known problematic modules"""
        try:
            # Only generate hooks for modules that are actually used
            used_modules = self._get_used_modules()
            if not used_modules:
                return
                
            self.pre_safe_dir.mkdir(parents=True, exist_ok=True)
            tmpl = (
                "# Auto-generated by minibuild_core: pre-safe import hook for {mod}\n"
                "def pre_safe_import_module(api):\n"
                "    import sys, argparse\n"
                "    try:\n"
                "        # Patch argparse to avoid argv side-effects during PyInstaller analysis\n"
                "        _orig_parse_args = argparse.ArgumentParser.parse_args\n"
                "        _orig_parse_known_args = argparse.ArgumentParser.parse_known_args\n"
                "        def _safe_parse_args(self, args=None, namespace=None):\n"
                "            return _orig_parse_args(self, args=[], namespace=namespace)\n"
                "        def _safe_parse_known_args(self, args=None, namespace=None):\n"
                "            return _orig_parse_known_args(self, args=[], namespace=namespace)\n"
                "        argparse.ArgumentParser.parse_args = _safe_parse_args\n"
                "        argparse.ArgumentParser.parse_known_args = _safe_parse_known_args\n"
                "    except Exception:\n"
                "        pass\n"
            )
            
            # Generate hooks only for modules that need them
            essential_modules = {"lightrag", "lightrag.api", "jaraco.text", "jaraco.functools"}
            for mod in essential_modules:
                if mod in used_modules:
                    (self.pre_safe_dir / f"hook-{mod}.py").write_text(tmpl.format(mod=mod), encoding="utf-8")
                    
        except Exception as e:
            print(f"[MINIBUILD] Warning: Failed to generate pre-safe hooks: {e}")

    def _ensure_global_sitecustomize(self) -> None:
        """Ensure a sitecustomize.py that patches argparse globally for isolated child processes."""
        try:
            self.gen_hooks_dir.mkdir(parents=True, exist_ok=True)
            sc = self.gen_hooks_dir / "sitecustomize.py"
            content = (
                "# Auto-generated by minibuild_core: global sitecustomize for PyInstaller isolated child\n"
                "import sys, os, argparse\n"
                "try:\n"
                "    # Only patch when running PyInstaller's isolated child (_child.py)\n"
                "    if hasattr(sys, 'argv') and len(sys.argv) > 0:\n"
                "        prog = os.path.basename(sys.argv[0]).lower()\n"
                "        if prog.endswith('_child.py'):\n"
                "            _orig_parse_args = argparse.ArgumentParser.parse_args\n"
                "            _orig_parse_known_args = argparse.ArgumentParser.parse_known_args\n"
                "            def _safe_parse_args(self, args=None, namespace=None):\n"
                "                return _orig_parse_args(self, args=[], namespace=namespace)\n"
                "            def _safe_parse_known_args(self, args=None, namespace=None):\n"
                "                return _orig_parse_known_args(self, args=[], namespace=namespace)\n"
                "            argparse.ArgumentParser.parse_args = _safe_parse_args\n"
                "            argparse.ArgumentParser.parse_known_args = _safe_parse_known_args\n"
                "except Exception:\n"
                "    pass\n"
            )
            sc.write_text(content, encoding="utf-8")
        except Exception as e:
            print(f"[MINIBUILD] Warning: Failed to generate sitecustomize: {e}")

    def _get_used_modules(self) -> Set[str]:
        """Get modules that are actually used in the project"""
        modules = set()

        # Add modules from config
        build_config = self.cfg.get("build", {})
        pyinstaller_cfg = build_config.get("pyinstaller", {})
        modules.update(pyinstaller_cfg.get("collect_all", []))
        modules.update(pyinstaller_cfg.get("collect_data_only", []))
        modules.update(pyinstaller_cfg.get("force_includes", []))
        modules.update(pyinstaller_cfg.get("force_hiddenimports", []))

        return modules

    def _get_python_executable(self) -> str:
        """Get the appropriate Python executable for PyInstaller"""
        # Check if we're in a virtual environment
        if hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
            # We're in a virtual environment, use the venv Python
            venv_python = self.project_root / "venv" / "bin" / "python3"
            if sys.platform.startswith("win"):
                venv_python = self.project_root / "venv" / "Scripts" / "python.exe"
            
            if venv_python.exists():
                return str(venv_python)
        
        # Fallback to current executable
        return sys.executable

    # ---- Spec generation ----
    def _write_spec(self, mode: str) -> Path:
        app = self.cfg.get("app", {})
        app_name = app.get("name", "app")
        main_script = app.get("entry_point", "main.py")
        icons = app.get("icons", {})
        icon_win = icons.get("windows", "eCan.ico")
        icon_mac = icons.get("macos", "eCan.icns")

        build_config = self.cfg.get("build", {})
        bmodes = build_config.get("modes", {})
        mode_cfg = bmodes.get(mode, {})
        onefile = bool(mode_cfg.get("onefile", False))
        console = bool(mode_cfg.get("console", app.get("console", False)))
        debug = bool(mode_cfg.get("debug", app.get("debug", False)))

        datas_lines = self._datas_from_config()
        hiddenimports = self._hiddenimports_from_config()

        spec_lines: List[str] = []
        spec_lines.append("# -*- mode: python ; coding: utf-8 -*-")
        spec_lines.append("import sys")
        spec_lines.append("from pathlib import Path")
        spec_lines.append("project_root = Path(r'" + str(self.project_root) + "')")
        spec_lines.append("")
        spec_lines.append("import os as _os, sys as _sys")
        spec_lines.append("")
        spec_lines.append("data_files = []")
        spec_lines.append("binaries = []")
        spec_lines.append("hiddenimports = " + repr(hiddenimports))
        spec_lines.extend(datas_lines)
        spec_lines.append("")

        # Collect all resources/hiddenimports/binaries for configured packages
        pyinstaller_cfg = build_config.get("pyinstaller", {})
        collect_pkgs = pyinstaller_cfg.get("collect_all", []) or []
        if collect_pkgs:
            spec_lines.append("from PyInstaller.utils.hooks import collect_all")
            spec_lines.append("hooked_bins = []")
            spec_lines.append("hooked_hidden = []")
            spec_lines.append("for _pkg in " + repr(collect_pkgs) + ":")
            spec_lines.append("    _d, _b, _h = collect_all(_pkg)")
            spec_lines.append("    data_files += _d")
            spec_lines.append("    binaries += _b")
            spec_lines.append("    hiddenimports += _h")
            spec_lines.append("")

        # Collect data-only for packages that cannot be imported in isolated child
        collect_data_only = pyinstaller_cfg.get("collect_data_only", []) or []
        if collect_data_only:
            spec_lines.append("from PyInstaller.utils.hooks import collect_data_files")
            spec_lines.append("for _pkg in " + repr(collect_data_only) + ":")
            spec_lines.append("    data_files += collect_data_files(_pkg)")
            spec_lines.append("")

        # Ensure QtWebEngineProcess.app and related resources are bundled for macOS
        if platform_handler.is_macos:
            spec_lines.append("# QtWebEngine resources for macOS")
            spec_lines.append("try:")
            spec_lines.append("    from PySide6 import __file__ as _pyside6_file")
            spec_lines.append("    _qt_lib = Path(_pyside6_file).parent / \"Qt\" / \"lib\"")
            spec_lines.append("    _qt_frameworks = Path(_pyside6_file).parent / \"Qt\" / \"lib\"")
            spec_lines.append("    ")
            spec_lines.append("    # QtWebEngineProcess.app")
            spec_lines.append("    _webengine_candidates = [")
            spec_lines.append("        _qt_lib / \"QtWebEngineCore.framework\" / \"Helpers\" / \"QtWebEngineProcess.app\",")
            spec_lines.append("        _qt_lib / \"QtWebEngineCore.framework\" / \"Versions\" / \"Current\" / \"Helpers\" / \"QtWebEngineProcess.app\",")
            spec_lines.append("    ]")
            spec_lines.append("    for p in _webengine_candidates:")
            spec_lines.append("        if p.exists():")
            spec_lines.append("            data_files.append((str(p), \"PySide6/Qt/lib/QtWebEngineCore.framework/Helpers\"))")
            spec_lines.append("            print(f'[QTWEBENGINE] Added QtWebEngineProcess.app: {p}')")
            spec_lines.append("            break")
            spec_lines.append("    ")
            spec_lines.append("    # QtWebEngine resources")
            spec_lines.append("    _webengine_resources = [")
            spec_lines.append("        _qt_lib / \"QtWebEngineCore.framework\" / \"Resources\",")
            spec_lines.append("        _qt_lib / \"QtWebEngineCore.framework\" / \"Versions\" / \"Current\" / \"Resources\",")
            spec_lines.append("    ]")
            spec_lines.append("    for res_dir in _webengine_resources:")
            spec_lines.append("        if res_dir.exists():")
            spec_lines.append("            data_files.append((str(res_dir), \"PySide6/Qt/lib/QtWebEngineCore.framework/Resources\"))")
            spec_lines.append("            print(f'[QTWEBENGINE] Added resources: {res_dir}')")
            spec_lines.append("            break")
            spec_lines.append("except Exception as e:")
            spec_lines.append("    print(f'[WARNING] Failed to locate QtWebEngine resources: {e}')")

        spec_lines.append("_playwright_third_party = project_root / \"third_party\" / \"ms-playwright\"")
        spec_lines.append("if _playwright_third_party.exists():")
        spec_lines.append("    data_files.append((str(_playwright_third_party), \"third_party/ms-playwright\"))")

        # Analysis section
        spec_lines.append("a = Analysis([")
        spec_lines.append(f"    r'{main_script}',")
        spec_lines.append("],")
        spec_lines.append("    pathex=[str(project_root)],")
        spec_lines.append("    binaries=binaries,")
        spec_lines.append("    datas=data_files,")
        spec_lines.append("    hiddenimports=hiddenimports,")
        # Add custom hooks path for unified symlink management
        hooks_path = str(Path(__file__).parent / "pyinstaller_hooks")
        spec_lines.append(f"    hookspath=[r'{hooks_path}'],  # Custom hooks for symlink management")
        spec_lines.append("    hooksconfig={},")

        # Handle codesign exclusions for macOS
        excludes = pyinstaller_cfg.get("excludes", [])
        codesign_excludes = []
        if platform_handler.is_macos:
            platform_config = self.cfg.get("platforms", {}).get("macos", {})
            codesign_config = platform_config.get("codesign", {})
            codesign_excludes = codesign_config.get("exclude_patterns", [])
            if codesign_excludes:
                for exclude in codesign_excludes:
                    spec_lines.append(f"    # codesign_exclude: {exclude}")
                spec_lines.append("")
        
        spec_lines.append("    excludes=" + repr(excludes) + ",")
        spec_lines.append("    runtime_hooks=[],")
        spec_lines.append("    win_no_prefer_redirects=False,")
        spec_lines.append("    win_private_assemblies=False,")
        
        # Get optimization settings
        opt_cfg = pyinstaller_cfg.get("optimization", {})
        copy_metadata = opt_cfg.get("copy_metadata", True)
        
        spec_lines.append("    cipher=None,")
        spec_lines.append("    noarchive=False,")
        spec_lines.append(f"    copy_metadata={copy_metadata},")
        spec_lines.append(")")
        spec_lines.append("")

        # Basic cleanup: remove duplicate entries
        spec_lines.append("seen_datas = set()")
        spec_lines.append("unique_datas = []")
        spec_lines.append("for data in a.datas:")
        spec_lines.append("    data_key = (data[0], data[1])")
        spec_lines.append("    if data_key not in seen_datas:")
        spec_lines.append("        seen_datas.add(data_key)")
        spec_lines.append("        unique_datas.append(data)")
        spec_lines.append("a.datas = unique_datas")
        spec_lines.append("")
        spec_lines.append("seen_bins = set()")
        spec_lines.append("unique_bins = []")
        spec_lines.append("for b in a.binaries:")
        spec_lines.append("    key = (b[0], b[1])")
        spec_lines.append("    if key not in seen_bins:")
        spec_lines.append("        seen_bins.add(key)")
        spec_lines.append("        unique_bins.append(b)")
        spec_lines.append("a.binaries = unique_bins")
        spec_lines.append("")
        
        # Post-analysis cleanup and duplicate detection
        spec_lines.append("# Universal cleanup and duplicate detection")
        spec_lines.append("import fnmatch")
        spec_lines.append("import subprocess")
        spec_lines.append("import os")
        spec_lines.append("from collections import defaultdict")
        spec_lines.append("")
        spec_lines.append("# Detect and remove duplicate files")
        spec_lines.append("file_registry = defaultdict(list)")
        spec_lines.append("for data in a.datas[:]:")
        spec_lines.append("    dest_path = str(data[0])")
        spec_lines.append("    source_path = str(data[1])")
        spec_lines.append("    file_registry[dest_path].append(data)")
        spec_lines.append("")
        spec_lines.append("duplicates_removed = 0")
        spec_lines.append("for dest_path, data_list in file_registry.items():")
        spec_lines.append("    if len(data_list) > 1:")
        spec_lines.append("        # Keep the first one, remove duplicates")
        spec_lines.append("        for duplicate in data_list[1:]:")
        spec_lines.append("            try:")
        spec_lines.append("                a.datas.remove(duplicate)")
        spec_lines.append("                duplicates_removed += 1")
        spec_lines.append("            except ValueError:")
        spec_lines.append("                pass  # Already removed")
        spec_lines.append("")
        spec_lines.append("print(f'[SPEC] Removed {duplicates_removed} duplicate data files')")
        spec_lines.append("")
        spec_lines.append("# macOS-specific processing")
        spec_lines.append("if _sys.platform == 'darwin':")
        spec_lines.append("    ")
        spec_lines.append("    # Get codesign exclusion patterns")
        if platform_handler.is_macos:
            spec_lines.append("    codesign_excludes = " + repr(codesign_excludes))
        else:
            spec_lines.append("    codesign_excludes = []")
        spec_lines.append("    ")
        spec_lines.append("    # Track removed and kept binaries")
        spec_lines.append("    excluded_binaries = []")
        spec_lines.append("    kept_binaries = []")
        spec_lines.append("    removed_count = 0")
        spec_lines.append("    ")
        spec_lines.append("    # Process each binary for codesign exclusions")
        spec_lines.append("    for binary in a.binaries[:]:")
        spec_lines.append("        dest_name = str(binary[0])")
        spec_lines.append("        source_path = str(binary[1]) if len(binary) > 1 else ''")
        spec_lines.append("        ")
        spec_lines.append("        # Check if should be excluded from codesign")
        spec_lines.append("        should_exclude = False")
        spec_lines.append("        for pattern in codesign_excludes:")
        spec_lines.append("            if fnmatch.fnmatch(dest_name, pattern) or fnmatch.fnmatch(source_path, pattern):")
        spec_lines.append("                should_exclude = True")
        spec_lines.append("                break")
        spec_lines.append("        ")
        spec_lines.append("        if should_exclude:")
        spec_lines.append("            excluded_binaries.append((dest_name, source_path))")
        spec_lines.append("            a.binaries.remove(binary)")
        spec_lines.append("            removed_count += 1")
        spec_lines.append("            continue")
        spec_lines.append("        ")
        spec_lines.append("        # Special handling for Playwright and QtWebEngine")
        spec_lines.append("        if any(pattern in dest_name.lower() for pattern in ['ms-playwright', 'chromium', 'chrome-mac', 'qtwebengine']):")
        spec_lines.append("            # Keep essential files")
        spec_lines.append("            if any(keep in dest_name.lower() for keep in ['browsers.json', 'package.json', '.json', '.plist']):")
        spec_lines.append("                kept_binaries.append(dest_name)")
        spec_lines.append("            # Remove problematic executables")
        spec_lines.append("            elif any(remove in dest_name.lower() for remove in ['chrome', 'chromium']) and not dest_name.endswith('.json'):")
        spec_lines.append("                if not any(keep in dest_name.lower() for keep in ['.framework/', '.app/']):")
        spec_lines.append("                    excluded_binaries.append((dest_name, source_path))")
        spec_lines.append("                    a.binaries.remove(binary)")
        spec_lines.append("                    removed_count += 1")
        spec_lines.append("                    continue")
        spec_lines.append("            kept_binaries.append(dest_name)")
        spec_lines.append("        ")
        spec_lines.append("    # Remove framework duplicates")
        spec_lines.append("    framework_duplicates = []")
        spec_lines.append("    for binary in a.binaries[:]:")
        spec_lines.append("        dest_name = str(binary[0])")
        spec_lines.append("        if ('.framework/Helpers/' in dest_name and")
        spec_lines.append("            '.framework/Versions/' not in dest_name and")
        spec_lines.append("            'QtWebEngineCore.framework' not in dest_name):")
        spec_lines.append("            versions_path = dest_name.replace('.framework/Helpers/', '.framework/Versions/Current/Helpers/')")
        spec_lines.append("            if any(str(b[0]) == versions_path for b in a.binaries):")
        spec_lines.append("                framework_duplicates.append(binary)")
        spec_lines.append("                a.binaries.remove(binary)")
        spec_lines.append("    ")
        spec_lines.append("    # Handle symlink conflicts in frameworks")
        spec_lines.append("    symlink_conflicts = []")
        spec_lines.append("    for data in a.datas[:]:")
        spec_lines.append("        dest_path = str(data[0])")
        spec_lines.append("        source_path = str(data[1])")
        spec_lines.append("        # Check for framework symlink conflicts")
        spec_lines.append("        if ('.framework/' in dest_path and")
        spec_lines.append("            ('Versions/Current/' in dest_path or 'Helpers' in dest_path)):")
        spec_lines.append("            # Check if this is a symlink that might conflict")
        spec_lines.append("            if os.path.islink(source_path):")
        spec_lines.append("                # Remove symlinks that might cause conflicts")
        spec_lines.append("                symlink_conflicts.append(data)")
        spec_lines.append("                a.datas.remove(data)")
        spec_lines.append("                continue")
        spec_lines.append("    ")
        spec_lines.append("    # Print summary")
        spec_lines.append("    print(f'[MACOS] Excluded {removed_count} binaries from codesign')")
        spec_lines.append("    print(f'[MACOS] Kept {len(kept_binaries)} essential binaries')")
        spec_lines.append("    print(f'[MACOS] Removed {len(framework_duplicates)} framework duplicates')")
        spec_lines.append("    print(f'[MACOS] Resolved {len(symlink_conflicts)} symlink conflicts')")
        spec_lines.append("")
        
        spec_lines.append("pyz = PYZ(a.pure, a.zipped_data, cipher=None)")
        spec_lines.append("")

        if onefile:
            # onefile EXE
            spec_lines.append("exe = EXE(")
            spec_lines.append("    pyz,")
            spec_lines.append("    a.scripts,")
            spec_lines.append("    a.binaries,")
            spec_lines.append("    a.zipfiles,")
            spec_lines.append("    a.datas,")
            spec_lines.append(f"    name='{app_name}',")
            spec_lines.append(f"    debug={repr(debug)},")
            spec_lines.append("    bootloader_ignore_signals=False,")
            spec_lines.append(f"    strip={'False' if sys.platform.startswith('win') else 'True'},")
            spec_lines.append("    upx=False,")
            spec_lines.append("    upx_exclude=[],")
            spec_lines.append("    runtime_tmpdir=None,")
            spec_lines.append(f"    console={repr(console)},")
            spec_lines.append("    icon=(r'" + (icon_mac if sys.platform == 'darwin' else icon_win) + "'),")
            spec_lines.append(")")
        else:
            # onedir EXE + COLLECT
            spec_lines.append("exe = EXE(")
            spec_lines.append("    pyz,")
            spec_lines.append("    a.scripts,")
            spec_lines.append("    [],")
            spec_lines.append("    exclude_binaries=True,")
            spec_lines.append(f"    name='{app_name}',")
            spec_lines.append(f"    debug={repr(debug)},")
            spec_lines.append("    bootloader_ignore_signals=False,")
            spec_lines.append(f"    strip={'False' if sys.platform.startswith('win') else 'True'},")
            spec_lines.append("    upx=False,")
            spec_lines.append("    upx_exclude=[],")
            spec_lines.append("    runtime_tmpdir=None,")
            spec_lines.append(f"    console={repr(console)},")
            spec_lines.append("    icon=(r'" + (icon_mac if sys.platform == 'darwin' else icon_win) + "'),")
            spec_lines.append(")")
            spec_lines.append("")
            spec_lines.append("coll = COLLECT(")
            spec_lines.append("    exe,")
            spec_lines.append("    a.binaries,")
            spec_lines.append("    a.zipfiles,")
            spec_lines.append("    a.datas,")
            spec_lines.append(f"    strip={'False' if sys.platform.startswith('win') else 'True'},")
            spec_lines.append("    upx=False,")
            spec_lines.append("    upx_exclude=[],")
            spec_lines.append("    exclude_binaries=False,")
            spec_lines.append("    name='{app_name}'".format(app_name=app_name))
            spec_lines.append(")")
            spec_lines.append("")
            
            # macOS app bundle wrapper
            spec_lines.append("if _sys.platform == 'darwin':")
            spec_lines.append("    app = BUNDLE(")
            spec_lines.append("        coll,")
            spec_lines.append(f"        name='{app_name}.app',")
            spec_lines.append("        icon=(r'" + icon_mac + "'),")
            spec_lines.append("    )")

        spec_path = self.project_root / f"{app_name}_{mode}.spec"
        spec_path.write_text("\n".join(spec_lines), encoding="utf-8")
        print(f"[MINIBUILD] Wrote spec: {spec_path}")
        return spec_path

    # ---- Helpers ----
    def _datas_from_config(self) -> List[str]:
        """Generate spec lines for data files/dirs, skipping entries that don't exist."""
        lines: List[str] = []
        build_config = self.cfg.get("build", {})
        data_cfg = build_config.get("data_files", {})
        
        # Directories
        for d in data_cfg.get("directories", []) or []:
            d_path = (self.project_root / d)
            if d_path.exists():
                lines.append(f"data_files.append((r'{d}', r'{d}'))")
            else:
                print(f"[MINIBUILD] Warning: data directory not found, skipping: {d_path}")
        
        # Files
        for f in data_cfg.get("files", []) or []:
            f_path = (self.project_root / f)
            if f_path.exists():
                lines.append(f"data_files.append((r'{f}', r'.'))")
            else:
                print(f"[MINIBUILD] Warning: data file not found, skipping: {f_path}")
        
        return lines

    def _hiddenimports_from_config(self) -> List[str]:
        """Get hiddenimports from config, with minimal essential additions"""
        base: Set[str] = set()

        # Merge with config
        build_config = self.cfg.get("build", {})
        pyinstaller_cfg = build_config.get("pyinstaller", {})
        for m in pyinstaller_cfg.get("force_includes", []) or []:
            if isinstance(m, str) and m:
                base.add(m)

        for m in pyinstaller_cfg.get("force_hiddenimports", []) or []:
            if isinstance(m, str) and m:
                base.add(m)

        return sorted(base)


__all__ = ["MiniSpecBuilder"]

