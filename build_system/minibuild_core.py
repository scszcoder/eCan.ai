#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Minibuild core: a simplified, maintainable build pipeline for PyInstaller.

Design goals:
- Single spec generator with minimal dynamic-import detection
- Minimal config surface (reuse build_system/build_config.json where possible)
- Default to onedir; onefile optional per mode
- Works on Windows and macOS; supports macOS .app (BUNDLE) and PKG via existing InstallerBuilder
- Very small hook surface (reuse existing build_system/pyinstaller_hooks)
"""
from __future__ import annotations

import json
import sys
import subprocess
import os
from pathlib import Path
from typing import Dict, List, Set, Any, Optional

# Import platform handler
try:
    from .platform_handler import platform_handler
except ImportError:
    # Handle case when imported directly
    from platform_handler import platform_handler


class MiniSpecBuilder:
    def __init__(self, project_root: Optional[Path] = None, config_path: str = "build_system/build_config.json"):
        self.project_root = project_root or Path.cwd()
        self.config_path = self.project_root / config_path
        with open(self.config_path, "r", encoding="utf-8") as f:
            self.cfg: Dict[str, Any] = json.load(f)
        # Generated hooks directory (for pre_safe_import_module)
        self.gen_hooks_dir = self.project_root / "build" / "pyinstaller_hooks_gen"
        self.pre_safe_dir = self.gen_hooks_dir / "pre_safe_import_module"

    # ---- Public API ----
    def build(self, mode: str = "prod", profile: Dict[str, Any] = None) -> bool:
        # Generate essential pre-safe hooks for known problematic modules
        self._ensure_pre_safe_hooks()
        self._ensure_global_sitecustomize()

        # Write spec file with profile settings
        self._last_spec_path = self._write_spec(mode, profile)
        
        # Run PyInstaller
        # Use virtual environment Python if available, fallback to sys.executable
        python_executable = self._get_python_executable()
        cmd = [python_executable, "-m", "PyInstaller", str(self._last_spec_path)]
        
        # Note: target architecture is now set in the spec file, not as command line argument
        target_arch = os.getenv('TARGET_ARCH')
        if target_arch and platform_handler.is_macos:
            if target_arch == 'aarch64':
                print(f"[MINIBUILD] Targeting ARM64 architecture (set in spec)")
            elif target_arch == 'amd64':
                print(f"[MINIBUILD] Targeting x86_64 architecture (set in spec)")
        
        profile = profile or {}
        print(f"[MINIBUILD] Starting {mode} build with profile: {profile}")
        print(f"[MINIBUILD] Profile settings will be applied in spec file generation")
        
        # Store profile for spec generation
        self._current_profile = profile
        
        # Only add basic PyInstaller args that don't conflict with spec file
        extra_args = ["--noconfirm", "--clean"]
        
        # Debug settings (can be applied as command line arg)
        if profile.get("debug", False):
            extra_args.append("--debug=all")
            
        # UPX compression (can be applied as command line arg)
        if profile.get("upx_compression", False):
            extra_args.append("--upx-dir=upx")
            
        # Strip debug info is handled in spec file, not as command line arg
        # if profile.get("strip_debug", False):
        #     extra_args.append("--strip")
        
        cmd.extend(extra_args)
        print(f"[MINIBUILD] PyInstaller command: {' '.join(cmd)}")
        env = os.environ.copy()
        py_path = str(self.gen_hooks_dir)
        env["PYTHONPATH"] = (py_path + (os.pathsep + env.get("PYTHONPATH", "") if env.get("PYTHONPATH") else ""))
        env["PYTHONUTF8"] = "1"
        
        result = subprocess.run(cmd, cwd=str(self.project_root), env=env)
        if result.returncode != 0:
            print(f"[MINIBUILD] {mode.upper()} build failed with code {result.returncode}")
            return False
        print(f"[MINIBUILD] {mode.upper()} build completed successfully with profile settings")
        return True

    def _ensure_pre_safe_hooks(self) -> None:
        """Generate essential pre-safe hooks for known problematic modules"""
        try:
            # Only generate hooks for modules that are actually used
            used_modules = self._get_used_modules()
            if not used_modules:
                return
                
            self.pre_safe_dir.mkdir(parents=True, exist_ok=True)
            tmpl = (
                "# Auto-generated by minibuild_core: pre-safe import hook for {mod}\n"
                "def pre_safe_import_module(api):\n"
                "    import sys, argparse\n"
                "    try:\n"
                "        # Patch argparse to avoid argv side-effects during PyInstaller analysis\n"
                "        _orig_parse_args = argparse.ArgumentParser.parse_args\n"
                "        _orig_parse_known_args = argparse.ArgumentParser.parse_known_args\n"
                "        def _safe_parse_args(self, args=None, namespace=None):\n"
                "            return _orig_parse_args(self, args=[], namespace=namespace)\n"
                "        def _safe_parse_known_args(self, args=None, namespace=None):\n"
                "            return _orig_parse_known_args(self, args=[], namespace=namespace)\n"
                "        argparse.ArgumentParser.parse_args = _safe_parse_args\n"
                "        argparse.ArgumentParser.parse_known_args = _safe_parse_known_args\n"
                "    except Exception:\n"
                "        pass\n"
            )
            
            # Generate hooks only for modules that need them
            essential_modules = {"lightrag", "lightrag.api", "jaraco.text", "jaraco.functools"}
            for mod in essential_modules:
                if mod in used_modules:
                    (self.pre_safe_dir / f"hook-{mod}.py").write_text(tmpl.format(mod=mod), encoding="utf-8")
                    
        except Exception as e:
            print(f"[MINIBUILD] Warning: Failed to generate pre-safe hooks: {e}")

    def _ensure_global_sitecustomize(self) -> None:
        """Ensure a sitecustomize.py that patches argparse globally for isolated child processes."""
        try:
            self.gen_hooks_dir.mkdir(parents=True, exist_ok=True)
            sc = self.gen_hooks_dir / "sitecustomize.py"
            content = (
                "# Auto-generated by minibuild_core: global sitecustomize for PyInstaller isolated child\n"
                "import sys, os, argparse\n"
                "try:\n"
                "    # Only patch when running PyInstaller's isolated child (_child.py)\n"
                "    if hasattr(sys, 'argv') and len(sys.argv) > 0:\n"
                "        prog = os.path.basename(sys.argv[0]).lower()\n"
                "        if prog.endswith('_child.py'):\n"
                "            _orig_parse_args = argparse.ArgumentParser.parse_args\n"
                "            _orig_parse_known_args = argparse.ArgumentParser.parse_known_args\n"
                "            def _safe_parse_args(self, args=None, namespace=None):\n"
                "                return _orig_parse_args(self, args=[], namespace=namespace)\n"
                "            def _safe_parse_known_args(self, args=None, namespace=None):\n"
                "                return _orig_parse_known_args(self, args=[], namespace=namespace)\n"
                "            argparse.ArgumentParser.parse_args = _safe_parse_args\n"
                "            argparse.ArgumentParser.parse_known_args = _safe_parse_known_args\n"
                "except Exception:\n"
                "    pass\n"
            )
            sc.write_text(content, encoding="utf-8")
        except Exception as e:
            print(f"[MINIBUILD] Warning: Failed to generate sitecustomize: {e}")

    def _get_used_modules(self) -> Set[str]:
        """Get modules that are actually used in the project"""
        modules = set()

        # Add modules from config
        build_config = self.cfg.get("build", {})
        pyinstaller_cfg = build_config.get("pyinstaller", {})
        modules.update(pyinstaller_cfg.get("collect_all", []))
        modules.update(pyinstaller_cfg.get("collect_data_only", []))
        modules.update(pyinstaller_cfg.get("hiddenimports", []))

        return modules

    def _get_python_executable(self) -> str:
        """Get Python executable path (prefer virtual environment)"""
        # Check for virtual environment Python
        if os.path.exists("venv"):
            if sys.platform.startswith("win"):
                venv_python = self.project_root / "venv" / "Scripts" / "python.exe"
            else:
                venv_python = self.project_root / "venv" / "bin" / "python"
            
            if venv_python.exists():
                print(f"[MINIBUILD] Using virtual environment Python: {venv_python}")
                return str(venv_python)
            else:
                print(f"[MINIBUILD] Virtual environment Python not found: {venv_python}")
        
        # Fallback to current executable
        print(f"[MINIBUILD] Using system Python: {sys.executable}")
        return sys.executable

    # ---- Spec generation ----
    def _write_spec(self, mode: str, profile: Dict[str, Any] = None) -> Path:
        """Generate a simplified PyInstaller spec file"""
        profile = profile or {}
        spec_name = f"eCan_{mode}.spec"
        app = self.cfg.get("app", {})
        app_name = app.get("name", "eCan")
        app_version = app.get("version", "1.0.0")
        main_script = app.get("entry_point", "main.py")

        build_config = self.cfg.get("build", {})
        mode_cfg = build_config.get("modes", {}).get(mode, {})
        # Apply profile settings to override mode defaults
        onefile = profile.get("onefile", bool(mode_cfg.get("onefile", False)))
        console_mode = profile.get("console", mode == "dev")
        debug = profile.get("debug", bool(mode_cfg.get("debug", app.get("debug", False))))

        # Get runtime_tmpdir configuration
        runtime_tmpdir = self._get_runtime_tmpdir(mode_cfg)

        # Generate spec content using template
        spec_content = self._generate_spec_template(
            app_name=app_name,
            app_version=app_version,
            main_script=main_script,
            mode=mode,
            onefile=onefile,
            console=console_mode,
            debug=debug,
            runtime_tmpdir=runtime_tmpdir,
            profile=profile
        )

        spec_path = self.project_root / f"{app_name}_{mode}.spec"
        spec_path.write_text(spec_content, encoding="utf-8")
        print(f"[MINIBUILD] Wrote spec: {spec_path}")
        return spec_path

    def _get_runtime_tmpdir(self, mode_cfg: Dict[str, Any]) -> Optional[str]:
        """Get runtime_tmpdir configuration for current platform"""
        runtime_tmpdir_cfg = mode_cfg.get("runtime_tmpdir", {})
        if not runtime_tmpdir_cfg:
            return None

        import sys
        if sys.platform.startswith('win'):
            return runtime_tmpdir_cfg.get("windows")
        elif sys.platform == 'darwin':
            return runtime_tmpdir_cfg.get("macos")
        else:
            return runtime_tmpdir_cfg.get("linux")

    def _generate_spec_template(self, app_name: str, app_version: str, main_script: str,
                               mode: str, onefile: bool, console: bool, debug: bool,
                               runtime_tmpdir: Optional[str], profile: Dict[str, Any] = None) -> str:
        """Generate spec file content using a clean template approach"""

        # Get configuration data
        hiddenimports = self._hiddenimports_from_config()
        data_files_code = self._generate_data_files_code()
        collect_packages_code = self._generate_collect_packages_code()
        excludes = self._get_excludes()

        # Icon configuration
        icons = self.cfg.get("app", {}).get("icons", {})
        icon_win = icons.get("windows", "eCan.ico")
        icon_mac = icons.get("macos", "eCan.icns")

        # Platform-specific settings
        platform_config = self._get_platform_config()

        # Profile-based settings
        if profile is None:
            profile = {}
        
        strip_debug = profile.get("strip_debug", False)
        upx_compression = profile.get("upx_compression", False)

        # Target architecture configuration for macOS
        target_arch_config = ""
        target_arch = os.getenv('TARGET_ARCH')
        pyinstaller_target_arch = os.getenv('PYINSTALLER_TARGET_ARCH')

        if platform_handler.is_macos:
            # Use explicit PyInstaller target architecture if provided
            if pyinstaller_target_arch:
                target_arch_config = f"target_arch='{pyinstaller_target_arch}',"
                print(f"[SPEC] Using explicit PyInstaller target architecture: {pyinstaller_target_arch}")
            elif target_arch:
                # Map common architecture names to PyInstaller format
                if target_arch in ['aarch64', 'arm64']:
                    target_arch_config = "target_arch='arm64',"
                    print(f"[SPEC] Mapped {target_arch} to PyInstaller arm64")
                elif target_arch in ['amd64', 'x86_64']:
                    # Check if we're running on ARM64 runner
                    import platform as py_platform
                    current_arch = py_platform.machine().lower()
                    if current_arch in ['arm64', 'aarch64']:
                        # On ARM64 runner, build universal binary for amd64 compatibility
                        target_arch_config = "target_arch='universal2',"
                        print(f"[SPEC] Mapped {target_arch} to PyInstaller universal2 (ARM64 + x86_64)")
                    else:
                        target_arch_config = "target_arch='x86_64',"
                        print(f"[SPEC] Mapped {target_arch} to PyInstaller x86_64")
                else:
                    print(f"[SPEC] Unknown target architecture: {target_arch}, using default")
            else:
                # Default to current architecture if not specified
                import platform as py_platform
                current_arch = py_platform.machine().lower()
                if current_arch in ['arm64', 'aarch64']:
                    target_arch_config = "target_arch='arm64',"
                    print(f"[SPEC] Auto-detected ARM64 architecture")
                else:
                    target_arch_config = "target_arch='x86_64',"
                    print(f"[SPEC] Auto-detected x86_64 architecture")

        template = f'''# -*- mode: python ; coding: utf-8 -*-
"""
Generated PyInstaller spec for {app_name} - {mode} mode
Auto-generated by eCan build system (simplified)
"""

import sys
import platform as py_platform
from pathlib import Path

# Project root and basic setup
project_root = Path(r'{str(self.project_root)}')
print(f'[SPEC] Project root: {{project_root}}')

# Architecture validation for macOS
if sys.platform == 'darwin':
    current_arch = py_platform.machine().lower()
    target_arch = '{target_arch or "auto"}'
    print(f'[SPEC] Current architecture: {{current_arch}}')
    print(f'[SPEC] Target architecture: {{target_arch}}')

    if target_arch == 'aarch64' and current_arch in ['x86_64', 'amd64']:
        print('[SPEC] WARNING: Cross-compiling ARM64 on Intel - may cause runtime issues')
    elif target_arch == 'amd64' and current_arch in ['arm64', 'aarch64']:
        print('[SPEC] WARNING: Cross-compiling Intel on ARM64 - may cause runtime issues')

# Initialize collections
data_files = []
binaries = []
hiddenimports = {repr(hiddenimports)}

{data_files_code}

{collect_packages_code}

# Add third-party assets
playwright_third_party = project_root / "third_party" / "ms-playwright"
if playwright_third_party.exists():
    data_files.append((str(playwright_third_party), "third_party/ms-playwright"))

# Icon detection
icon_path = None
if sys.platform.startswith('win'):
    icon_candidates = [
        project_root / '{icon_win}',
        project_root / 'resource' / 'icon.ico',
        project_root / 'resource' / 'eCan.ico'
    ]
elif sys.platform == 'darwin':
    icon_candidates = [
        project_root / '{icon_mac}',
        project_root / 'resource' / 'icon.icns',
        project_root / 'resource' / 'eCan.icns'
    ]
else:
    icon_candidates = []

for candidate in icon_candidates:
    if candidate.exists():
        icon_path = str(candidate)
        print(f'[SPEC] Using icon: {{icon_path}}')
        break

if not icon_path:
    print('[SPEC] Warning: No icon file found')

# Analysis
a = Analysis(
    [r'{main_script}'],
    pathex=[str(project_root)],
    binaries=binaries,
    datas=data_files,
    hiddenimports=hiddenimports,
    hookspath=[str(project_root / 'build_system' / 'pyinstaller_hooks')],
    hooksconfig={{}},
    excludes={repr(excludes)},
    runtime_hooks=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=None,
    noarchive=False,
    copy_metadata=True,
    {target_arch_config}
)

# Simple deduplication
print("[SPEC] Removing duplicates...")
a.datas = list(dict.fromkeys(a.datas))
a.binaries = list(dict.fromkeys(a.binaries))

# Drop heavy tests/examples/__pycache__ from datas to reduce size and avoid perms
drop_tokens = ['/tests/', '/testing/', '/__pycache__/', '/examples/']

def _should_drop_path(p):
    try:
        lp = str(p).lower().replace('\\\\\\\\', '/').replace('\\\\', '/')
        for tok in drop_tokens:
            if tok in lp:
                return True
    except Exception:
        pass
    return False

new_datas = []
dropped = 0

for item in list(a.datas):
    try:
        dest = str(item[0])
        src = str(item[1]) if len(item) > 1 else ""

        # Check for test/example/cache files
        if _should_drop_path(dest) or _should_drop_path(src):
            dropped += 1
            continue
    except Exception:
        pass
    new_datas.append(item)

a.datas = new_datas
print("[SPEC] Dropped %d test/example/cache data files" % dropped)
print(f"[SPEC] Final counts - Data: {{len(a.datas)}}, Binaries: {{len(a.binaries)}}")

{platform_config}

pyz = PYZ(a.pure, a.zipped_data, cipher=None)

{self._generate_exe_config(app_name, app_version, onefile, console, debug, runtime_tmpdir)}
'''
        return template
    def _generate_data_files_code(self) -> str:
        """Generate code for data files collection with symlink handling"""
        lines = []
        build_config = self.cfg.get("build", {})
        data_cfg = build_config.get("data_files", {})

        lines.append("# Data files with cross-platform processing")
        lines.append("from build_system.build_utils import process_data_files")
        lines.append("import platform")
        lines.append("")
        lines.append(f"data_files_config = {repr(data_cfg)}")
        lines.append("processed_data_files = process_data_files(data_files_config, verbose=True)")
        lines.append("")
        lines.append("for src_path, dst_path in processed_data_files:")
        lines.append("    if Path(src_path).exists():")
        lines.append("        data_files.append((src_path, dst_path))")
        lines.append("        print(f'[SPEC] Added data: {src_path} -> {dst_path}')")
        lines.append("    else:")
        lines.append("        print(f'[SPEC] Warning: Data file not found: {src_path}')")

        return "\n".join(lines)

    def _generate_collect_packages_code(self) -> str:
        """Generate code for package collection (simplified)"""
        build_config = self.cfg.get("build", {})
        pyinstaller_cfg = build_config.get("pyinstaller", {})

        lines = []

        # Collect all packages
        collect_pkgs = pyinstaller_cfg.get("collect_all", []) or []
        if collect_pkgs:
            lines.append("from PyInstaller.utils.hooks import collect_all")
            lines.append(f"for pkg in {repr(collect_pkgs)}:")
            lines.append("    try:")
            lines.append("        d, b, h = collect_all(pkg)")
            lines.append("        data_files.extend(d)")
            lines.append("        binaries.extend(b)")
            lines.append("        # Filter out invalid hiddenimports from collect_all")
            lines.append("        valid_h = [m for m in h if isinstance(m, str) and not ('hook-' in m or '_pyinstaller' in m or '/' in m or '\\\\' in m)]")
            lines.append("        hiddenimports.extend(valid_h)")
            lines.append("        if len(h) != len(valid_h):")
            lines.append("            print(f'[SPEC] Filtered {len(h) - len(valid_h)} invalid hiddenimports from {pkg}')")
            lines.append("        print(f'[SPEC] Collected: {pkg}')")
            lines.append("    except Exception as e:")
            lines.append("        print(f'[SPEC] Warning: Failed to collect {pkg}: {e}')")

        # Collect data-only packages
        collect_data_only = pyinstaller_cfg.get("collect_data_only", []) or []
        if collect_data_only:
            lines.append("")
            lines.append("from PyInstaller.utils.hooks import collect_data_files")
            lines.append(f"for pkg in {repr(collect_data_only)}:")
            lines.append("    try:")
            lines.append("        data_files.extend(collect_data_files(pkg))")
            lines.append("        print(f'[SPEC] Collected data: {pkg}')")
            lines.append("    except Exception as e:")
            lines.append("        print(f'[SPEC] Warning: Failed to collect data for {pkg}: {e}')")

        return "\n".join(lines)

    def _get_excludes(self) -> List[str]:
        """Get excludes list from configuration"""
        build_config = self.cfg.get("build", {})
        pyinstaller_cfg = build_config.get("pyinstaller", {})
        return pyinstaller_cfg.get("excludes", [])

    def _get_platform_config(self) -> str:
        """Generate platform-specific configuration code"""
        if not platform_handler.is_macos:
            return ""

        platform_config = self.cfg.get("platforms", {}).get("macos", {})
        codesign_config = platform_config.get("codesign", {})
        codesign_excludes = codesign_config.get("exclude_patterns", [])

        if not codesign_excludes:
            return ""

        return f'''# macOS-specific binary filtering
if sys.platform == 'darwin':
    import fnmatch
    codesign_excludes = {repr(codesign_excludes)}

    # Remove binaries that should be excluded from codesign
    filtered_binaries = []
    for binary in a.binaries:
        dest_name = str(binary[0])
        source_path = str(binary[1]) if len(binary) > 1 else ''

        should_exclude = any(
            fnmatch.fnmatch(dest_name, pattern) or fnmatch.fnmatch(source_path, pattern)
            for pattern in codesign_excludes
        )

        if not should_exclude:
            filtered_binaries.append(binary)

    removed_count = len(a.binaries) - len(filtered_binaries)
    a.binaries = filtered_binaries
    print(f"[MACOS] Excluded {{removed_count}} binaries from codesign")
'''

    def _generate_exe_config(self, app_name: str, app_version: str, onefile: bool, console: bool,
                           debug: bool, runtime_tmpdir: Optional[str]) -> str:
        """Generate EXE and packaging configuration"""

        if onefile:
            return f'''exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    name='{app_name}',
    debug={repr(debug)},
    bootloader_ignore_signals=False,
    strip=False if sys.platform.startswith('win') else {strip_debug},
    upx={upx_compression},
    runtime_tmpdir={repr(runtime_tmpdir)},
    console={repr(console)},
    icon=icon_path,
)'''
        else:
            return f'''exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='{app_name}',
    debug={repr(debug)},
    bootloader_ignore_signals=False,
    strip=False if sys.platform.startswith('win') else {strip_debug},
    upx={upx_compression},
    runtime_tmpdir={repr(runtime_tmpdir)},
    console={repr(console)},
    icon=icon_path,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False if sys.platform.startswith('win') else {strip_debug},
    upx={upx_compression},
    name='{app_name}'
)

# macOS app bundle
if sys.platform == 'darwin':
    app = BUNDLE(
        coll,
        name='{app_name}.app',
        icon=icon_path,
        bundle_identifier='com.ecan.app',
        info_plist={{
            'CFBundleName': '{app_name}',
            'CFBundleDisplayName': '{app_name}',
            'CFBundleVersion': '{app_version}',
            'CFBundleShortVersionString': '{app_version}',
            'CFBundleExecutable': '{app_name}',
            'CFBundleIdentifier': 'com.ecan.app',
            'CFBundlePackageType': 'APPL',
            'CFBundleSignature': '????',
            'CFBundleInfoDictionaryVersion': '6.0',
            'LSApplicationCategoryType': 'public.app-category.productivity',
            'LSMinimumSystemVersion': '10.14.0',
            'NSHighResolutionCapable': True,
            'NSRequiresAquaSystemAppearance': False,
            'NSSupportsAutomaticGraphicsSwitching': True,
            'NSAppTransportSecurity': {{'NSAllowsArbitraryLoads': True}},
            'NSMicrophoneUsageDescription': '{app_name} needs microphone access for voice features',
            'NSCameraUsageDescription': '{app_name} needs camera access for visual features',
            'NSNetworkVolumesUsageDescription': '{app_name} needs network access for automation',
            'NSAppleEventsUsageDescription': '{app_name} needs AppleEvents access for system automation',
            'NSSystemAdministrationUsageDescription': '{app_name} needs admin access for system automation',
            'LSUIElement': False,
            'LSBackgroundOnly': False,
        }},
    )
'''

    # ---- Helpers ----
    def _hiddenimports_from_config(self) -> List[str]:
        """Get hiddenimports from config with validation"""
        base: Set[str] = set()
        build_config = self.cfg.get("build", {})
        pyinstaller_cfg = build_config.get("pyinstaller", {})

        # Add hidden imports with validation
        for m in pyinstaller_cfg.get("hiddenimports", []) or []:
            if isinstance(m, str) and m:
                # Filter out invalid module names (hook files, paths, etc.)
                if self._is_valid_module_name(m):
                    base.add(m)
                else:
                    print(f"[SPEC] Skipping invalid hiddenimport: {m}")

        return sorted(base)

    def _is_valid_module_name(self, module_name: str) -> bool:
        """Check if a string is a valid Python module name"""
        # Skip hook files
        if "hook-" in module_name:
            return False
        
        # Skip file paths
        if "/" in module_name or "\\" in module_name:
            return False
        
        # Skip _pyinstaller internal modules
        if "_pyinstaller" in module_name:
            return False
        
        # Must not be empty
        if not module_name.strip():
            return False
        
        # Check each part separated by dots
        parts = module_name.split(".")
        for part in parts:
            if not part:  # Empty part
                return False
            
            # Must start with letter or underscore (not digit)
            if not (part[0].isalpha() or part[0] == '_'):
                return False
            
            # Must contain only alphanumeric characters and underscores
            if not part.replace("_", "").isalnum():
                return False
        
        return True


__all__ = ["MiniSpecBuilder"]

