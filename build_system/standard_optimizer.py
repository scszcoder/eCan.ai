#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PyInstaller 标准优化器
使用 PyInstaller 的标准优化方法，而不是自定义缓存系统
"""

import os
import sys
import json
import subprocess
from pathlib import Path
from typing import List, Dict, Any


class PyInstallerOptimizer:
    """PyInstaller 标准优化器"""
    
    def __init__(self, config_path: str = "build_system/build_config.json"):
        self.config_path = Path(config_path)
        self.config = self._load_config()
        self.project_root = Path.cwd()
        # Directory for generated (ephemeral) PyInstaller hooks
        self.generated_hooks_dir = self.project_root / 'build' / 'pyinstaller_hooks_gen'
        self.generated_pre_safe_dir = self.generated_hooks_dir / 'pre_safe_import_module'

    def _load_config(self) -> Dict[str, Any]:
        """加载构建配置"""
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"[OPTIMIZER] Failed to load config: {e}")
            return {}
    
    def _ensure_generated_pre_safe_hooks(self, targets: list[str] | None = None):
        """Generate minimal pre-safe-import hooks under pre_safe_import_module/hook-<mod>.py
        to sanitize sys.argv for problematic modules before import in isolated child.
        """
        try:
            # Ensure directories
            self.generated_pre_safe_dir.mkdir(parents=True, exist_ok=True)
            # Default targets – can be extended by smart detector in future
            if targets is None:
                targets = [
                    'lightrag.api',
                    'lightrag.api.config',
                ]
            # Top-level code executes as pre-safe import hook
            hook_tmpl = (
                "# Auto-generated by standard_optimizer: pre-safe import hook for {mod}\n"
                "def pre_safe_import_module(api):\n"
                "    import sys\n"
                "    try:\n"
                "        if hasattr(sys, 'argv') and isinstance(sys.argv, list) and len(sys.argv) > 1:\n"
                "            sys.argv[:] = sys.argv[:1]\n"
                "    except Exception:\n"
                "        pass\n"
            )
            for mod in targets:
                # File name must be hook-<module>.py inside pre_safe_import_module
                fn = f"hook-{mod}.py"
                (self.generated_pre_safe_dir / fn).write_text(hook_tmpl.format(mod=mod), encoding='utf-8')
        except Exception as e:
            print(f"[OPTIMIZER] Failed to generate pre-safe hooks: {e}")

    def generate_optimized_spec(self, mode: str = "fast") -> str:
        """生成优化的 .spec 文件"""
        app_info = self.config.get('app_info', {})
        pyinstaller_config = self.config.get('pyinstaller', {})
        build_mode = self.config.get('build_modes', {}).get(mode, {})
        optimization = pyinstaller_config.get('optimization', {})
        
        # 合并配置（build_mode 覆盖 pyinstaller_config）
        final_config = {**pyinstaller_config, **build_mode}

        # 规范化 collect_* 配置：支持 "all"/"minimal"/列表
        def _norm_list(key: str, default_list: list):
            v = final_config.get(key, default_list)
            if isinstance(v, str):
                if v.lower() == 'all':
                    return default_list
                if v.lower() == 'minimal':
                    return []
            return v or []

        collect_data_cfg = _norm_list('collect_data', pyinstaller_config.get('collect_data', []))
        collect_bins_cfg = _norm_list('collect_binaries', pyinstaller_config.get('collect_binaries', []))
        collect_submods_cfg = _norm_list('collect_submodules', pyinstaller_config.get('collect_submodules', []))
        collect_all_modules = pyinstaller_config.get('collect_all', [])

        # 平台分路径支持：runtime_tmpdir 可为字符串或 {windows|macos|linux} 映射
        runtime_tmpdir_cfg = final_config.get('runtime_tmpdir', None)
        if isinstance(runtime_tmpdir_cfg, dict):
            plat = sys.platform
            plat_key = 'windows' if plat.startswith('win') else ('macos' if plat == 'darwin' else 'linux')
            runtime_tmpdir_cfg = runtime_tmpdir_cfg.get(plat_key)
        # 展开用户目录符号
        if isinstance(runtime_tmpdir_cfg, str) and ('~' in runtime_tmpdir_cfg or runtime_tmpdir_cfg.startswith('~')):
            from os.path import expanduser
            runtime_tmpdir_cfg = expanduser(runtime_tmpdir_cfg)

        spec_content = f'''# -*- mode: python ; coding: utf-8 -*-
# PyInstaller 标准优化配置
# 生成时间: {self._get_timestamp()}

import sys
from pathlib import Path

# 项目根目录
project_root = Path(r"{self.project_root}")

# 数据文件收集
data_files = []
'''
        
        # 添加数据文件（prod 模式剔除 tests 目录）
        data_files = self.config.get('data_files', {})
        if data_files.get('directories'):
            spec_content += "\n# 目录数据文件\n"
            for directory in data_files['directories']:
                spec_content += f'data_files.append((r"{directory}", r"{directory}"))\n'

        if data_files.get('files'):
            spec_content += "\n# 单个数据文件\n"
            for file in data_files['files']:
                spec_content += f'data_files.append((r"{file}", "."))\n'

        # 智能检测器集成
        spec_content += '''
# 智能动态检测器
try:
    from build_system.smart_dynamic_detector import SmartDynamicDetector
    detector = SmartDynamicDetector(project_root)
    smart_hiddenimports = detector.detect_smart_imports()
    print(f"[OPTIMIZER] Smart detector found {len(smart_hiddenimports)} hidden imports")
    # 同步检测需要收集数据文件的第三方包（例如使用 importlib.resources 的包）
    try:
        smart_data_modules = detector.detect_resource_packages()
        print(f"[OPTIMIZER] Smart detector suggested {len(smart_data_modules)} data modules")
    except Exception as de:
        print(f"[OPTIMIZER] Resource package detection failed: {de}")
        smart_data_modules = []
except Exception as e:
    print(f"[OPTIMIZER] Smart detector failed: {e}")
    smart_hiddenimports = []
    smart_data_modules = []

'''
        
        # 基础隐藏导入
        base_hiddenimports = pyinstaller_config.get('hidden_imports', [])

        # 强制包含的模块
        force_includes = pyinstaller_config.get('force_includes', [])

        # Qt 插件
        qt_plugins = pyinstaller_config.get('qt_plugins', [])
        
        # Analysis 配置
        spec_content += f'''
# Analysis 配置
a = Analysis(
    [r"{app_info.get('main_script', 'main.py')}"],
    pathex=[str(project_root)],
    binaries=[],
    datas=data_files,
    hiddenimports={base_hiddenimports} + smart_hiddenimports + {force_includes},
    hookspath=[str(project_root / 'build_system' / 'pyinstaller_hooks'), str(project_root / 'build' / 'pyinstaller_hooks_gen')],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes={pyinstaller_config.get('excludes', [])},
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=None,
    noarchive=False,
)

'''
        
        # 收集数据和二进制文件（使用合并后的配置）
        collect_data = collect_data_cfg
        collect_binaries = collect_bins_cfg
        collect_submodules = collect_submods_cfg

        if collect_data:
            spec_content += f'''
# 安全收集数据文件
from PyInstaller.utils.hooks import collect_data_files

def safe_collect_data_files(module_name):
    """安全地收集数据文件，确保格式正确"""
    try:
        datas = collect_data_files(module_name)
        valid_datas = []
        for item in datas:
            if isinstance(item, (tuple, list)) and len(item) >= 2:
                # 确保是三元组格式 (source, dest, type)
                if len(item) == 2:
                    valid_datas.append((str(item[0]), str(item[1]), 'DATA'))
                else:
                    valid_datas.append((str(item[0]), str(item[1]), str(item[2])))
        return valid_datas
    except Exception as e:
        print(f"[OPTIMIZER] Failed to collect data for {{module_name}}: {{e}}")
        return []

# 收集数据文件（静态配置）
for module in {collect_data}:
    valid_datas = safe_collect_data_files(module)
    if valid_datas:
        a.datas.extend(valid_datas)
        print(f"[OPTIMIZER] Collected data for {{module}}: {{len(valid_datas)}} files")

# 收集数据文件（智能检测建议）
for module in smart_data_modules:
    valid_datas = safe_collect_data_files(module)
    if valid_datas:
        a.datas.extend(valid_datas)
        print(f"[OPTIMIZER] Collected data for {{module}} via smart detector: {{len(valid_datas)}} files")

'''
        
        if collect_binaries:
            spec_content += f'''
# 安全收集二进制文件
from PyInstaller.utils.hooks import collect_dynamic_libs

def safe_collect_binaries(module_name):
    """安全地收集二进制文件，确保格式正确"""
    try:
        binaries = collect_dynamic_libs(module_name)
        valid_binaries = []
        for item in binaries:
            if isinstance(item, (tuple, list)) and len(item) >= 2:
                # 确保是三元组格式 (source, dest, type)
                if len(item) == 2:
                    valid_binaries.append((str(item[0]), str(item[1]), 'BINARY'))
                else:
                    valid_binaries.append((str(item[0]), str(item[1]), str(item[2])))
        return valid_binaries
    except Exception as e:
        print(f"[OPTIMIZER] Failed to collect binaries for {{module_name}}: {{e}}")
        return []

# 收集二进制文件
for module in {collect_binaries}:
    valid_binaries = safe_collect_binaries(module)
    if valid_binaries:
        a.binaries.extend(valid_binaries)
        print(f"[OPTIMIZER] Collected binaries for {{module}}: {{len(valid_binaries)}} files")

'''
        
        if collect_submodules:
            spec_content += f'''
# 安全收集子模块
from PyInstaller.utils.hooks import collect_submodules

def safe_collect_submodules(module_name):
    """安全地收集子模块"""
    try:
        submodules = collect_submodules(module_name)
        # 确保子模块名称是字符串格式
        valid_submodules = [str(mod) for mod in submodules if mod]
        return valid_submodules
    except Exception as e:
        print(f"[OPTIMIZER] Failed to collect submodules for {{module_name}}: {{e}}")
        return []

# 收集子模块
for module in {collect_submodules}:
    valid_submodules = safe_collect_submodules(module)
    if valid_submodules:
        a.hiddenimports.extend(valid_submodules)
        print(f"[OPTIMIZER] Collected submodules for {{module}}: {{len(valid_submodules)}} modules")

'''
        
        # PYZ 配置
        spec_content += f'''
# PYZ 配置（Python 字节码归档）
pyz = PYZ(
    a.pure, 
    a.zipped_data,
    cipher=None
)

'''
        
        # EXE 配置
        onefile = final_config.get('onefile', False)
        console = final_config.get('console', False)
        debug = final_config.get('debug', False)
        strip_debug = final_config.get('strip_debug', True)
        upx_compress = final_config.get('upx_compress', False)
        compression = final_config.get('compression', None)

        # onefile 模式特定优化
        if onefile:
            print("[OPTIMIZER] Applying onefile-specific optimizations...")
            # 减少不必要的数据收集
            if str(final_config.get('collect_data', '')).lower() == 'minimal':
                print("  • Minimal data collection enabled")
            if final_config.get('lazy_imports', False):
                print("  • Lazy imports enabled")
            if upx_compress:
                print("  • UPX compression enabled")
            if compression:
                print(f"  • Archive compression: {compression}")
        
        # 根据模式生成不同的 EXE 配置
        if onefile:
            # macOS onefile 模式的图标和配置
            if sys.platform == 'darwin':
                installer_config = self.config.get('installer', {})
                macos_config = installer_config.get('macos', {})
                icon_path = app_info.get('icon_macos', 'eCan.icns')
                
                spec_content += f'''
# EXE 配置 (onefile 模式 - macOS)
exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    name="{app_info.get('name', 'app')}",
    debug={debug},
    bootloader_ignore_signals=False,
    strip={strip_debug},
    upx={upx_compress},
    upx_exclude=[],
    runtime_tmpdir={repr(runtime_tmpdir_cfg)},
    console={console},
    disable_windowed_traceback=False,
    target_arch=None,
    codesign_identity="",
    entitlements_file=None,
    icon=r"{icon_path}",
    # macOS onefile 兼容性设置
    bundle_identifier="{macos_config.get('bundle_identifier', 'com.ecan.app')}",
    info_plist={{
        'CFBundleName': "{macos_config.get('app_name', app_info.get('name', 'eCan'))}",
        'CFBundleDisplayName': "{macos_config.get('app_name', app_info.get('name', 'eCan'))}",
        'CFBundleVersion': "{macos_config.get('app_version', app_info.get('version', '1.0.0'))}",
        'CFBundleShortVersionString': "{macos_config.get('app_version', app_info.get('version', '1.0.0'))}",
        'CFBundleGetInfoString': "{macos_config.get('copyright', 'Copyright © 2025 eCan.AI Team')}",
        'NSHighResolutionCapable': True,
        'LSUIElement': False,
        'NSRequiresAquaSystemAppearance': False,
        # macOS 兼容性修复
        'LSMinimumSystemVersion': '11.0',  # 支持macOS Big Sur及以上
        'LSArchitecturePriority': ['x86_64', 'arm64'],  # 支持Intel和Apple Silicon
        'NSSupportsAutomaticGraphicsSwitching': True,  # 支持自动图形切换
        'NSPrincipalClass': 'NSApplication',  # 确保正确的应用程序类
    }}
)

'''
            else:
                spec_content += f'''
# EXE 配置 (onefile 模式)
exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    name="{app_info.get('name', 'app')}",
    debug={debug},
    bootloader_ignore_signals=False,
    strip={strip_debug},
    upx={upx_compress},
    upx_exclude=[],
    runtime_tmpdir={repr(runtime_tmpdir_cfg)},
    console={console},
    disable_windowed_traceback=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=r"{app_info.get('icon_windows', 'eCan.ico')}"
)

'''
        else:
            # macOS onedir 模式的图标配置
            if sys.platform == 'darwin':
                icon_path = app_info.get('icon_macos', 'eCan.icns')
                spec_content += f'''
# EXE 配置 (onedir 模式 - macOS)
exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name="{app_info.get('name', 'app')}",
    debug={debug},
    bootloader_ignore_signals=False,
    strip={strip_debug},
    upx={upx_compress},
    upx_exclude=[],
    runtime_tmpdir=None,
    console={console},
    disable_windowed_traceback=False,
    target_arch=None,
    codesign_identity="",
    entitlements_file=None,
    icon=r"{icon_path}"
)

'''
            else:
                spec_content += f'''
# EXE 配置 (onedir 模式)
exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name="{app_info.get('name', 'app')}",
    debug={debug},
    bootloader_ignore_signals=False,
    strip={strip_debug},
    upx={upx_compress},
    upx_exclude=[],
    runtime_tmpdir=None,
    console={console},
    disable_windowed_traceback=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=r"{app_info.get('icon_windows', 'eCan.ico')}"
)

'''
        
        # COLLECT 配置（仅在 onedir 模式下）
        if not onefile:
            spec_content += f'''
# 数据验证和清理
print("[OPTIMIZER] Validating TOC entries...")

# 验证并修复数据格式
def validate_toc_entries(entries, entry_type):
    """验证并修复TOC条目格式"""
    valid_entries = []
    for entry in entries:
        if isinstance(entry, (tuple, list)):
            if len(entry) == 2:
                # 二元组转换为三元组 (source, dest, type)
                valid_entries.append((entry[0], entry[1], 'DATA'))
            elif len(entry) >= 3:
                # 已经是三元组或更多，保留前三个元素
                valid_entries.append((entry[0], entry[1], entry[2]))
    return valid_entries

a.binaries = validate_toc_entries(a.binaries, 'BINARY')
a.zipfiles = validate_toc_entries(a.zipfiles, 'ZIPFILE')
a.datas = validate_toc_entries(a.datas, 'DATA')

print(f"[OPTIMIZER] Validated binaries: {{len(a.binaries)}} entries")
print(f"[OPTIMIZER] Validated zipfiles: {{len(a.zipfiles)}} entries")
print(f"[OPTIMIZER] Validated datas: {{len(a.datas)}} entries")

# 进一步清理无效/目录型资源，避免 BUNDLE 资源校验报错
import os as _os
_cleaned_datas = []
_skipped_datas = 0
for _src, _dest, _typ in a.datas:
    try:
        # 跳过源是目录的条目（BUNDLE 资源必须是文件）
        if _os.path.isdir(_src):
            _skipped_datas += 1
            continue
        # 跳过明显的占位或无效路径
        if isinstance(_dest, str) and (_dest.endswith('/.dylibs') or _dest.endswith('\\.dylibs') or _dest.endswith('/__pycache__')):
            _skipped_datas += 1
            continue
        _cleaned_datas.append((_src, _dest, _typ))
    except Exception:
        _cleaned_datas.append((_src, _dest, _typ))
if _skipped_datas:
    print(f"[OPTIMIZER] Pruned invalid/dir resources from datas: {{_skipped_datas}} removed")
a.datas = _cleaned_datas

# macOS: prune Sparkle.framework symlink-conflict entries to avoid FileExistsError during COLLECT
import sys as _sys
if _sys.platform == 'darwin':
    def _prune_framework_symlink_conflicts(entries, framework_rel_path):
        pruned = []
        for entry in entries:
            try:
                src, dest, typ = entry
            except Exception:
                pruned.append(entry)
                continue
            # Remove alias paths that would conflict with symlinks inside the framework
            if isinstance(dest, str):
                if dest.startswith(framework_rel_path + "/Resources/") or dest == (framework_rel_path + "/Resources"):
                    continue
                if dest.startswith(framework_rel_path + "/Headers/") or dest == (framework_rel_path + "/Headers"):
                    continue
                if dest == (framework_rel_path + "/Sparkle"):
                    continue
            pruned.append((src, dest, typ))
        return pruned
    _framework_rel = "ota/dependencies/Sparkle.framework"
    _before = len(a.datas)
    a.datas = _prune_framework_symlink_conflicts(a.datas, _framework_rel)
    _after = len(a.datas)
    print(f"[OPTIMIZER] Pruned Sparkle.framework symlink-conflict entries: {{_before - _after}} removed")

# Qt 插件收集（如需要）
qt_plugins = {qt_plugins}
if qt_plugins:
    try:
        from PyInstaller.utils.hooks.qt import add_qt5_dependencies
        add_qt5_dependencies(a)
        print(f"[OPTIMIZER] Qt plugins requested: {qt_plugins}")
    except Exception as _e:
        print(f"[OPTIMIZER] Qt plugin setup skipped: {{_e}}")

# 修复 PyTorch 路径问题（macOS BUNDLE 兼容性）
import sys as _sys
if _sys.platform == 'darwin':
    def fix_torch_paths(entries, entry_type="binaries"):
        """修复 PyTorch 相关文件的路径问题"""
        fixed_entries = []
        for entry in entries:
            if len(entry) >= 2:
                src, dest = entry[0], entry[1]
                # 如果是 torch 相关的文件，进行路径修复
                if 'torch' in str(src) and str(src).startswith('/'):
                    # 检查是否是 torch/lib 目录下的文件
                    if 'torch/lib' in str(src):
                        # 提取文件名，重新映射到 Frameworks 目录
                        import os as _os
                        filename = _os.path.basename(str(src))
                        new_dest = "Frameworks/" + filename
                        fixed_entries.append((src, new_dest, entry[2] if len(entry) > 2 else 'BINARY'))
                        print("[OPTIMIZER] Fixed torch path: " + filename + " -> Frameworks/" + filename)
                    # 检查是否是其他 torch 相关路径
                    elif 'site-packages/torch' in str(src):
                        # 跳过有问题的 torch 符号链接和库文件
                        import os as _os
                        if _os.path.islink(str(src)) or str(src).endswith('.dylib') or str(src).endswith('.so'):
                            print("[OPTIMIZER] Skipping problematic torch file: " + str(src))
                            continue
                        else:
                            fixed_entries.append(entry)
                    else:
                        fixed_entries.append(entry)
                else:
                    fixed_entries.append(entry)
            else:
                fixed_entries.append(entry)
        return fixed_entries

    # 应用修复到二进制文件
    a.binaries = fix_torch_paths(a.binaries, "binaries")
    print("[OPTIMIZER] Applied PyTorch binary path fix for macOS BUNDLE")
    
    # 应用修复到数据文件（如果包含 torch 相关文件）
    a.datas = fix_torch_paths(a.datas, "datas")
    print("[OPTIMIZER] Applied PyTorch data path fix for macOS BUNDLE")

# COLLECT 配置（目录模式）
coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip={strip_debug},
    upx={upx_compress},
    upx_exclude=[],
    name="{app_info.get('name', 'app')}"
)

'''
        
        # macOS 特定配置（仅在 onedir 模式下）
        if sys.platform == 'darwin' and not onefile:
            installer_config = self.config.get('installer', {})
            macos_config = installer_config.get('macos', {})
            spec_content += f'''
# macOS App Bundle 配置
app = BUNDLE(
    coll,
    name="{macos_config.get('app_name', app_info.get('name', 'eCan'))}.app",
    icon=r"{app_info.get('icon_macos', 'eCan.icns')}",
    bundle_identifier="{macos_config.get('bundle_identifier', 'com.ecan.app')}",
    version="{macos_config.get('app_version', app_info.get('version', '1.0.0'))}",
    info_plist={{
        'CFBundleName': "{macos_config.get('app_name', app_info.get('name', 'eCan'))}",
        'CFBundleDisplayName': "{macos_config.get('app_name', app_info.get('name', 'eCan'))}",
        'CFBundleVersion': "{macos_config.get('app_version', app_info.get('version', '1.0.0'))}",
        'CFBundleShortVersionString': "{macos_config.get('app_version', app_info.get('version', '1.0.0'))}",
        'CFBundleGetInfoString': "{macos_config.get('copyright', 'Copyright © 2025 eCan.AI Team')}",
        'NSHighResolutionCapable': True,
        'LSUIElement': False,
        'NSRequiresAquaSystemAppearance': False,
        # macOS 兼容性修复
        'LSMinimumSystemVersion': '11.0',  # 支持macOS Big Sur及以上
        'LSArchitecturePriority': ['x86_64', 'arm64'],  # 支持Intel和Apple Silicon
        'NSSupportsAutomaticGraphicsSwitching': True,  # 支持自动图形切换
        'NSPrincipalClass': 'NSApplication',  # 确保正确的应用程序类
    }}
)
'''
        
        return spec_content
    
    def _get_timestamp(self) -> str:
        """获取当前时间戳"""
        import datetime
        return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def _force_clean_build_dirs(self) -> bool:
        """强制清理构建目录（处理权限问题文件）"""
        try:
            import shutil
            from pathlib import Path
            
            # 需要清理的目录
            dirs_to_clean = ['build', 'dist']
            
            for dir_name in dirs_to_clean:
                target_path = Path(self.project_root) / dir_name
                if target_path.exists():
                    try:
                        # 首先尝试常规删除
                        shutil.rmtree(target_path)
                        print(f"[OPTIMIZER] Cleaned {dir_name} directory")
                    except (PermissionError, OSError) as e:
                        print(f"[OPTIMIZER] Permission issue with {dir_name}, trying force clean...")
                        # macOS/Linux 强制删除
                        if sys.platform in ['darwin', 'linux']:
                            try:
                                subprocess.run(['rm', '-rf', str(target_path)], check=True, capture_output=True)
                                print(f"[OPTIMIZER] Force cleaned {dir_name} using system command")
                            except subprocess.CalledProcessError:
                                print(f"[ERROR] Cannot clean {dir_name} - build may fail")
                                return False
                        else:
                            # Windows 强制删除
                            try:
                                subprocess.run(['rmdir', '/s', '/q', str(target_path)], check=True, capture_output=True, shell=True)
                                print(f"[OPTIMIZER] Force cleaned {dir_name} using system command")
                            except subprocess.CalledProcessError:
                                print(f"[ERROR] Cannot clean {dir_name} - build may fail")
                                return False
            
            return True
            
        except Exception as e:
            print(f"[ERROR] Force clean failed: {e}")
            return False
    
    def build_optimized(self, mode: str = "fast", spec_file: str = None) -> bool:
        """使用标准优化构建应用"""
        try:
            # 强制清理构建目录（处理权限问题）
            build_mode = self.config.get('build_modes', {}).get(mode, {})
            if build_mode.get('clean', True):
                if not self._force_clean_build_dirs():
                    print("[WARNING] Force clean failed, continuing with build...")
            
            # 生成 spec 文件
            if not spec_file:
                spec_file = f"eCan_{mode}.spec"
            
            spec_content = self.generate_optimized_spec(mode)
            
            # 写入 spec 文件
            with open(spec_file, 'w', encoding='utf-8') as f:
                f.write(spec_content)
            
            print(f"[OPTIMIZER] Generated optimized spec file: {spec_file}")
            
            # 在生成 spec 之前，由智能检测器给出需要的预导入钩子列表，并生成（集中式管理，避免仓库大量静态 hook 文件）
            try:
                from build_system.smart_dynamic_detector import SmartDynamicDetector
                det = SmartDynamicDetector(self.project_root)
                pre_safe_targets = det.detect_pre_safe_modules()
            except Exception as e:
                print(f"[OPTIMIZER] Pre-safe detection failed: {e}")
                pre_safe_targets = ['lightrag.api', 'lightrag.api.config']
            self._ensure_generated_pre_safe_hooks(pre_safe_targets)

            # 构建命令
            build_mode = self.config.get('build_modes', {}).get(mode, {})

            cmd = [
                sys.executable, "-m", "PyInstaller",
                spec_file,
                "--noconfirm"
            ]

            # 智能缓存逻辑
            use_cache = build_mode.get('use_cache', False)
            clean = build_mode.get('clean', True)

            if clean and not use_cache:
                cmd.append("--clean")
                print("[OPTIMIZER] Cache disabled, cleaning previous build")
            elif use_cache:
                print("[OPTIMIZER] Cache enabled, preserving previous build")
            else:
                cmd.append("--clean")
                print("[OPTIMIZER] Cleaning previous build")
            
            # Note: PyInstaller doesn't support --parallel flag directly
            # Parallel processing is handled internally by PyInstaller
            if build_mode.get('parallel', True):
                workers = self.config.get('pyinstaller', {}).get('workers', 0)
                if workers > 0:
                    # Set environment variable for PyInstaller to use multiple workers
                    import os
                    os.environ['PYINSTALLER_COMPILE_BOOTLOADER'] = '1'
                    print(f"[OPTIMIZER] Parallel processing enabled with {workers} workers")
            
            # macOS 代码签名禁用（兼容性修复）
            env = os.environ.copy()
            if sys.platform == 'darwin':
                env['CODESIGN_ALLOCATE'] = '/usr/bin/true'  # 禁用代码签名
                env['CODE_SIGN_IDENTITY'] = ''
                print("[OPTIMIZER] Disabled code signing for macOS compatibility")
            
            # 执行构建
            print(f"[OPTIMIZER] Building with command: {' '.join(cmd)}")
            result = subprocess.run(cmd, cwd=self.project_root, env=env)
            
            if result.returncode == 0:
                print(f"[OPTIMIZER] Build successful in {mode} mode")
                return True
            else:
                print(f"[OPTIMIZER] Build failed with return code {result.returncode}")
                return False
                
        except Exception as e:
            print(f"[OPTIMIZER] Build error: {e}")
            return False
    
    def print_optimization_info(self):
        """打印优化信息"""
        print("PyInstaller 标准优化器")
        print("=" * 50)
        
        optimization = self.config.get('pyinstaller', {}).get('optimization', {})
        
        print("优化选项:")
        for key, value in optimization.items():
            print(f"  • {key}: {value}")
        
        print(f"\n可用构建模式:")
        for mode, config in self.config.get('build_modes', {}).items():
            print(f"  • {mode}: onefile={config.get('onefile', False)}, "
                  f"debug={config.get('debug', False)}, "
                  f"optimize={config.get('optimize', False)}")


def main():
    """主函数"""
    import argparse
    
    parser = argparse.ArgumentParser(description="PyInstaller 标准优化器")
    parser.add_argument("--mode", default="fast", choices=["dev", "fast", "prod"],
                       help="构建模式")
    parser.add_argument("--spec", help="自定义 spec 文件名")
    parser.add_argument("--info", action="store_true", help="显示优化信息")
    
    args = parser.parse_args()
    
    optimizer = PyInstallerOptimizer()
    
    if args.info:
        optimizer.print_optimization_info()
    else:
        success = optimizer.build_optimized(args.mode, args.spec)
        sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
